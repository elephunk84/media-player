{
  "id": "snapshot_1762786551272_hxx03rlnn",
  "approvalId": "approval_1762786551270_kx6p4dg9f",
  "approvalTitle": "Tasks Document - Rich Metadata Import",
  "version": 1,
  "timestamp": "2025-11-10T14:55:51.272Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Implementation Tasks\n\n- [ ] 1. Create database migration for rich metadata schema\n  - File: backend/src/migrations/003_rich_metadata_schema.ts\n  - Create tables: tags, categories, performers\n  - Create junction tables: media_file_tags, media_file_categories, media_file_performers\n  - Add columns to media_files table (display_name, provider, thumbnail, duration, etc.)\n  - Add indexes and foreign key constraints\n  - Implement both up() and down() methods for MySQL and PostgreSQL\n  - Purpose: Establish database schema foundation for rich metadata storage\n  - _Leverage: backend/src/migrations/001_initial_schema.ts, backend/src/migrations/002_create_media_files_table.ts, backend/src/adapters/DatabaseAdapter.ts_\n  - _Requirements: 3, 8_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Database Engineer specializing in MySQL/PostgreSQL schema design and migrations | Task: Create migration 003_rich_metadata_schema.ts that creates normalized tables (tags, categories, performers) with their junction tables and adds rich metadata columns to media_files, following requirements 3 and 8. Support both MySQL and PostgreSQL syntax patterns from existing migrations 001 and 002. Implement case-insensitive unique constraints using LOWER() function, add CASCADE DELETE foreign keys, create indexes on all foreign key columns and searchable fields. Include both up() and down() methods for rollback capability. | Restrictions: Must maintain backward compatibility with existing media_files records (new columns default to NULL), do not modify existing tables except media_files, follow exact column names and types from design.md, test both MySQL and PostgreSQL syntax, do not use database-specific features that aren't supported in both | _Leverage: Study migration patterns in 001_initial_schema.ts and 002_create_media_files_table.ts for handling MySQL vs PostgreSQL differences (AUTO_INCREMENT vs SERIAL, JSON vs JSONB, parameter placeholders) | Success: Migration creates all 6 tables with correct schemas, adds 10 columns to media_files, all foreign keys and indexes are created, runs successfully on both MySQL and PostgreSQL, down() method cleanly removes all changes, existing media_files records remain valid. After completing this task, mark task 1 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (include all table schemas created), then mark as [x] when complete.\n\n- [ ] 2. Create TypeScript model interfaces\n  - Files: backend/src/models/Tag.ts, backend/src/models/Category.ts, backend/src/models/Performer.ts, backend/src/models/MediaFile.ts (enhance existing)\n  - Define Tag, Category, Performer interfaces with id, name, timestamps\n  - Enhance MediaFile interface with new fields (displayName, provider, thumbnail, etc.)\n  - Add ParsedRichMetadata, ProviderInfo, FormatInfo interfaces\n  - Purpose: Establish type safety for rich metadata structures\n  - _Leverage: backend/src/models/MediaFile.ts (existing), backend/src/models/Video.ts, backend/src/models/Clip.ts_\n  - _Requirements: 1, 2, 3, 7_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: TypeScript Developer specializing in type systems and data modeling | Task: Create model interface files for Tag, Category, and Performer following requirements 3 and 7, and enhance existing MediaFile interface following requirements 1 and 2. Each interface should match the database schema exactly with readonly fields for id/timestamps. Create supporting interfaces ParsedRichMetadata (all extracted metadata fields), ProviderInfo (provider, providerId, webpageUrl), FormatInfo (downloadedFormat, availableFormats). Follow existing model patterns from Video.ts and Clip.ts for consistent structure. | Restrictions: Must use readonly for fields that shouldn't be modified after creation (id, createdAt), follow camelCase naming convention (database snake_case maps to TypeScript camelCase), ensure null types match database nullable columns, do not add methods to interfaces (pure data structures), maintain backward compatibility with existing MediaFile usage | _Leverage: Study existing model patterns in Video.ts, Clip.ts, and MediaFile.ts for timestamp handling, nullable fields, and metadata structures | Success: All interfaces compile without errors, match database schema exactly, follow project conventions, nullable fields are properly typed, supporting interfaces cover all metadata parsing needs. After completing this task, mark task 2 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list all interfaces created with their key properties), then mark as [x] when complete.\n\n- [ ] 3. Create TagManager utility\n  - File: backend/src/utils/TagManager.ts\n  - Implement findOrCreateTag(name: string): Promise<number>\n  - Implement findOrCreateTags(names: string[]): Promise<number[]> for batch operations\n  - Implement associateTagsWithMediaFile(uuid: string, tagIds: number[]): Promise<void>\n  - Implement syncMediaFileTags(uuid: string, tagNames: string[]): Promise<void> for full sync\n  - Implement getTagsForMediaFile(uuid: string): Promise<Tag[]>\n  - Implement removeMediaFileAssociations(uuid: string): Promise<void>\n  - Use transactions for atomic operations\n  - Handle case-insensitive matching (normalize to lowercase)\n  - Purpose: Provide reusable tag management operations\n  - _Leverage: backend/src/adapters/DatabaseAdapter.ts, backend/src/models/Tag.ts_\n  - _Requirements: 3, 8_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with expertise in database operations and utility design | Task: Create TagManager utility class following requirement 3 with methods for tag CRUD and media file associations. Implement case-insensitive tag matching by normalizing names to lowercase before queries. Use DatabaseAdapter for all operations with parameterized queries. Implement findOrCreateTag to check for existing tag (case-insensitive) and create if not exists, returning tag ID. Implement syncMediaFileTags to perform full sync (remove old associations, add new ones) within a transaction. Handle duplicate key errors gracefully (reuse existing tag). | Restrictions: Must use DatabaseAdapter methods exclusively (no raw SQL strings in this file), all operations must be transaction-safe, normalize tag names to lowercase for case-insensitive matching, handle both MySQL and PostgreSQL parameter syntax through adapter, do not catch errors silently (let them bubble to service layer), validate inputs (non-empty strings) | _Leverage: Study DatabaseAdapter interface for query, execute, and transaction methods. Use existing transaction patterns if found in other utilities | Success: All methods work correctly with both MySQL and PostgreSQL, case-insensitive matching prevents duplicates (\"Action\" == \"action\"), transactions rollback on failure, batch operations are efficient, errors are properly propagated. After completing this task, mark task 3 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list all functions with signatures and purpose), then mark as [x] when complete.\n\n- [ ] 4. Create CategoryManager utility\n  - File: backend/src/utils/CategoryManager.ts\n  - Implement findOrCreateCategory(name: string): Promise<number>\n  - Implement findOrCreateCategories(names: string[]): Promise<number[]>\n  - Implement associateCategoriesWithMediaFile(uuid: string, categoryIds: number[]): Promise<void>\n  - Implement syncMediaFileCategories(uuid: string, categoryNames: string[]): Promise<void>\n  - Implement getCategoriesForMediaFile(uuid: string): Promise<Category[]>\n  - Implement removeMediaFileAssociations(uuid: string): Promise<void>\n  - Use transactions for atomic operations\n  - Handle case-insensitive matching\n  - Purpose: Provide reusable category management operations\n  - _Leverage: backend/src/adapters/DatabaseAdapter.ts, backend/src/models/Category.ts, backend/src/utils/TagManager.ts (similar patterns)_\n  - _Requirements: 3, 8_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with expertise in database operations and code reusability | Task: Create CategoryManager utility class following requirement 3, mirroring the structure and patterns of TagManager but for categories. Implement all methods with same signatures as TagManager but operating on categories and category_id columns. Reuse the same case-insensitive matching approach and transaction patterns. | Restrictions: Must follow exact same patterns as TagManager (consistency is critical), use DatabaseAdapter methods exclusively, normalize category names to lowercase, all operations transaction-safe, validate inputs, do not duplicate code (consider extracting common patterns if significant duplication), handle both MySQL and PostgreSQL | _Leverage: Use TagManager.ts as the template - copy structure and adapt for categories table. Study how TagManager handles transactions and error cases | Success: CategoryManager follows exact same patterns as TagManager, all methods work correctly, case-insensitive matching works, transactions are atomic, code is consistent with TagManager implementation. After completing this task, mark task 4 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list all functions), then mark as [x] when complete.\n\n- [ ] 5. Create PerformerManager utility\n  - File: backend/src/utils/PerformerManager.ts\n  - Implement findOrCreatePerformer(name: string): Promise<number>\n  - Implement findOrCreatePerformers(names: string[]): Promise<number[]>\n  - Implement associatePerformersWithMediaFile(uuid: string, performerIds: number[]): Promise<void>\n  - Implement syncMediaFilePerformers(uuid: string, performerNames: string[]): Promise<void>\n  - Implement getPerformersForMediaFile(uuid: string): Promise<Performer[]>\n  - Implement removeMediaFileAssociations(uuid: string): Promise<void>\n  - Use transactions for atomic operations\n  - Handle case-insensitive matching\n  - Purpose: Provide reusable performer management operations\n  - _Leverage: backend/src/adapters/DatabaseAdapter.ts, backend/src/models/Performer.ts, backend/src/utils/TagManager.ts, backend/src/utils/CategoryManager.ts_\n  - _Requirements: 7, 8_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with expertise in database operations and pattern replication | Task: Create PerformerManager utility class following requirement 7, mirroring TagManager and CategoryManager patterns but for performers. Implement all methods with same signatures operating on performers table and performer_id columns. Maintain consistency with other manager utilities. | Restrictions: Must follow exact same patterns as TagManager and CategoryManager for consistency, use DatabaseAdapter methods exclusively, normalize performer names to lowercase, all operations transaction-safe, validate inputs, ensure three manager utilities are structurally identical except for table/column names | _Leverage: Use TagManager.ts and CategoryManager.ts as templates. All three managers should have nearly identical structure for maintainability | Success: PerformerManager follows exact same patterns as Tag/CategoryManager, all methods work correctly, case-insensitive matching works, transactions are atomic, three manager utilities are consistent in structure and error handling. After completing this task, mark task 5 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list all functions), then mark as [x] when complete.\n\n- [ ] 6. Create MetadataParser utility\n  - File: backend/src/utils/MetadataParser.ts\n  - Implement parseRichMetadata(rawMetadata: any): ParsedRichMetadata\n  - Implement extractDisplayName(metadata: any): string with fallback logic\n  - Implement extractTags(metadata: any): string[] with normalization\n  - Implement extractCategories(metadata: any): string[]\n  - Implement extractPerformers(metadata: any): string[]\n  - Implement extractProviderInfo(metadata: any): ProviderInfo\n  - Implement extractThumbnail(metadata: any): string | null with URL validation\n  - Implement extractDuration(metadata: any): number | null with type validation\n  - Implement extractFormats(metadata: any): FormatInfo\n  - Implement validateMetadata(parsed: ParsedRichMetadata): ValidationResult\n  - Purpose: Parse and validate rich metadata from .info.json files\n  - _Leverage: backend/src/utils/MetadataReader.ts, backend/src/models/MediaFile.ts (ParsedRichMetadata interface)_\n  - _Requirements: 1, 2, 3, 4, 5, 6, 7_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Data Engineering Specialist with expertise in parsing and validation | Task: Create MetadataParser utility with pure functions for extracting rich metadata from .info.json files following requirements 1-7. Implement extractDisplayName with fallback chain: display_name > title > filename. Implement extractTags to parse tags array and normalize (trim, lowercase). Implement extractPerformers to extract from pornstars array. Implement extractProviderInfo to extract provider, id (as providerId), webpage_url. Implement extractThumbnail with URL format validation (http/https scheme). Implement extractDuration with integer validation. Implement extractFormats to extract formats array and downloaded_format field. Implement parseRichMetadata to call all extractors and return ParsedRichMetadata object. Implement validateMetadata to check for invalid URLs, negative durations, empty required fields and return ValidationResult with errors/warnings arrays. | Restrictions: All functions must be pure (no side effects, no database access), handle missing/null fields gracefully (return null or empty arrays, never throw), validate URL format using regex, ensure integers for duration (return null if non-numeric), normalize strings (trim whitespace), do not modify input objects, return immutable data structures | _Leverage: Study MetadataReader.ts for metadata file reading patterns. Reference the JSON example structure from requirements.md | Success: All extraction functions handle missing fields gracefully, display name fallback works correctly (display_name > title > filename), URL validation prevents invalid formats, duration validation ensures integers, array extraction handles empty/missing arrays, validation function identifies all error scenarios, all functions are pure and testable. After completing this task, mark task 6 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list all functions with signatures and validation rules), then mark as [x] when complete.\n\n- [ ] 7. Enhance MediaLoaderService\n  - File: backend/src/services/MediaLoaderService.ts (modify existing)\n  - Add private method processRichMetadata(uuid: string, metadata: any): Promise<void>\n  - Add private method syncAssociations(uuid: string, parsed: ParsedRichMetadata): Promise<void>\n  - Enhance storeMediaFiles() to call processRichMetadata after inserting media file\n  - Add transaction support for metadata + associations (atomic operation)\n  - Update LoaderStatistics interface to include tags/categories/performers counts\n  - Enhance error handling to log metadata parsing failures\n  - Purpose: Orchestrate rich metadata import workflow\n  - _Leverage: backend/src/services/MediaLoaderService.ts (existing), backend/src/utils/MetadataParser.ts, backend/src/utils/TagManager.ts, backend/src/utils/CategoryManager.ts, backend/src/utils/PerformerManager.ts_\n  - _Requirements: All requirements (orchestrates entire feature)_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior Backend Developer with expertise in service orchestration and transaction management | Task: Enhance existing MediaLoaderService to integrate rich metadata parsing and storage. Add processRichMetadata method that: 1) calls MetadataParser.parseRichMetadata, 2) updates media_files columns (display_name, provider, thumbnail, etc.), 3) calls syncAssociations. Add syncAssociations method that: 1) calls TagManager.syncMediaFileTags, 2) calls CategoryManager.syncMediaFileCategories, 3) calls PerformerManager.syncMediaFilePerformers, 4) updates primary_tag_id if primary_tag exists. Integrate processRichMetadata into existing storeMediaFiles method after the current media file insert, within the same transaction. Enhance LoaderStatistics interface to add: tagsCreated, categoriesCreated, performersCreated, associationsCreated. Update statistics tracking to count new entities. Add error handling: catch metadata parsing errors, log to errorMessages, continue processing other files (graceful degradation). | Restrictions: Must maintain existing batch processing logic (100 files per batch), use existing transaction boundaries (don't create nested transactions), ensure backward compatibility (service works if metadata is missing), do not break existing tests, handle errors gracefully (one file's metadata failure shouldn't stop batch), update updated_at only if data changed, always update last_scanned_at, validate all manager methods are called within transaction | _Leverage: Study existing MediaLoaderService implementation carefully - understand current batch logic, transaction handling, statistics tracking, error handling patterns. Integrate new functionality without disrupting existing flow | Success: MediaLoaderService successfully orchestrates rich metadata import, metadata parsing errors don't stop batch processing, all operations are transactional, statistics accurately track new entities, existing functionality remains intact, service handles missing metadata gracefully, primary_tag is set correctly if exists, all three manager sync methods are called within transaction. After completing this task, mark task 7 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list new methods added, enhanced statistics fields, integration points), then mark as [x] when complete.\n\n- [ ] 8. Create TagManager unit tests\n  - File: backend/tests/utils/TagManager.test.ts\n  - Test findOrCreateTag with new tag (should create)\n  - Test findOrCreateTag with existing tag (should reuse)\n  - Test case-insensitive matching (\"Action\" == \"action\")\n  - Test findOrCreateTags batch operation\n  - Test associateTagsWithMediaFile\n  - Test syncMediaFileTags (add new, remove old)\n  - Test getTagsForMediaFile\n  - Test removeMediaFileAssociations\n  - Test transaction rollback on error\n  - Purpose: Ensure TagManager reliability and edge cases\n  - _Leverage: backend/tests/adapters/MySQLAdapter.test.ts, backend/tests/adapters/PostgreSQLAdapter.test.ts (test patterns)_\n  - _Requirements: 3_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in unit testing and Jest test framework | Task: Create comprehensive unit tests for TagManager following requirement 3. Mock DatabaseAdapter to isolate TagManager logic. Test findOrCreateTag: 1) new tag creates record and returns ID, 2) existing tag returns existing ID, 3) case-insensitive matching works (\"Action\" finds \"action\"). Test findOrCreateTags: batch creates multiple tags correctly. Test syncMediaFileTags: 1) adds new associations, 2) removes old associations not in new list, 3) preserves unchanged associations. Test error handling: database errors are propagated, transactions rollback on failure. Test edge cases: empty arrays, null inputs, special characters in names. | Restrictions: Must mock DatabaseAdapter completely (no real database calls), test both success and failure scenarios, verify SQL queries are parameterized (inspect adapter calls), verify case normalization logic, test isolation (each test independent), no shared state between tests, verify transaction methods are called | _Leverage: Study existing adapter tests for mocking patterns. Use Jest mocking to spy on DatabaseAdapter method calls | Success: All TagManager methods are tested, case-insensitive matching verified, transaction handling verified, edge cases covered, tests pass consistently, good code coverage (>80%), mocking isolates unit under test. After completing this task, mark task 8 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list test suites and key test cases), then mark as [x] when complete.\n\n- [ ] 9. Create CategoryManager and PerformerManager unit tests\n  - Files: backend/tests/utils/CategoryManager.test.ts, backend/tests/utils/PerformerManager.test.ts\n  - Mirror TagManager test structure for both managers\n  - Test all methods: findOrCreate, batch operations, associations, sync\n  - Test case-insensitive matching for both\n  - Test transaction handling for both\n  - Purpose: Ensure all manager utilities are thoroughly tested\n  - _Leverage: backend/tests/utils/TagManager.test.ts (copy structure), backend/tests/adapters/ (mocking patterns)_\n  - _Requirements: 3, 7_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in test pattern replication and consistency | Task: Create unit test files for CategoryManager and PerformerManager following requirements 3 and 7, mirroring the exact test structure from TagManager.test.ts. Copy test cases from TagManager tests and adapt for categories/performers (change table names, column names, but keep same test logic). Ensure both test files have identical test coverage as TagManager tests (same scenarios, edge cases, error handling). | Restrictions: Must maintain test consistency across all three manager utilities (identical test coverage), mock DatabaseAdapter completely, test isolation required, no real database calls, verify case-insensitive matching, verify transaction handling, test edge cases identically | _Leverage: Use TagManager.test.ts as the template - copy entire structure and adapt names/tables. This ensures consistent test coverage across all managers | Success: CategoryManager and PerformerManager have identical test coverage as TagManager, all tests pass, case-insensitive matching verified for both, transaction handling verified, edge cases covered, tests are structurally consistent. After completing this task, mark task 9 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list test files and test suite structure), then mark as [x] when complete.\n\n- [ ] 10. Create MetadataParser unit tests\n  - File: backend/tests/utils/MetadataParser.test.ts\n  - Test extractDisplayName fallback logic (display_name > title > filename)\n  - Test extractTags with various inputs (array, empty, null)\n  - Test extractCategories with various inputs\n  - Test extractPerformers from pornstars array\n  - Test extractProviderInfo with all fields\n  - Test extractThumbnail with valid/invalid URLs\n  - Test extractDuration with integer/string/null\n  - Test extractFormats with formats array and downloaded_format\n  - Test parseRichMetadata integration (calls all extractors)\n  - Test validateMetadata with valid/invalid data\n  - Purpose: Ensure metadata parsing handles all edge cases\n  - _Leverage: Example metadata JSON from requirements.md_\n  - _Requirements: 1, 2, 3, 4, 5, 6, 7_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in data parsing and validation testing | Task: Create comprehensive unit tests for MetadataParser covering requirements 1-7. Test extractDisplayName: 1) uses display_name if present, 2) falls back to title if display_name missing, 3) falls back to filename if both missing. Test extractTags: handles array of strings, empty array, null/undefined, trims whitespace, normalizes case. Test extractPerformers: extracts from pornstars array, handles empty array. Test extractProviderInfo: extracts provider, id (as providerId), webpage_url, handles missing fields. Test extractThumbnail: accepts valid URLs (http/https), rejects invalid URLs, handles missing field. Test extractDuration: accepts integers, rejects non-numeric, handles null. Test extractFormats: extracts formats array and downloaded_format. Test parseRichMetadata: calls all extractors and returns complete object. Test validateMetadata: identifies invalid URLs, negative durations, returns errors array. Use example JSON from requirements.md as test fixture. | Restrictions: All tests must be pure unit tests (no external dependencies), test each function independently, test both valid and invalid inputs, test null/undefined handling, test edge cases (empty arrays, special characters, very long strings), verify validation catches all error types, no database or file system access | _Leverage: Use the example metadata JSON from requirements.md as the primary test fixture. Create variations for edge cases | Success: All MetadataParser functions are tested, fallback logic verified, validation catches all error types, edge cases handled correctly, null/undefined handled gracefully, tests pass consistently, good coverage (>90%). After completing this task, mark task 10 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list test suites and validation test cases), then mark as [x] when complete.\n\n- [ ] 11. Create MediaLoaderService integration tests\n  - File: backend/tests/services/MediaLoaderService.integration.test.ts\n  - Test full import workflow with rich metadata\n  - Test updating existing media file (associations change)\n  - Test handling missing metadata gracefully\n  - Test statistics tracking (tags/categories/performers counts)\n  - Test error handling (one file fails, others succeed)\n  - Test transaction rollback on database error\n  - Use test database for real database operations\n  - Purpose: Verify end-to-end import workflow\n  - _Leverage: backend/tests/services/ (existing integration test patterns), backend/e2e/seed/init-db.sql (test database setup)_\n  - _Requirements: All requirements (end-to-end validation)_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration Test Engineer with expertise in end-to-end testing and database testing | Task: Create integration tests for enhanced MediaLoaderService covering all requirements. Set up test database with migration 003 applied. Create test metadata files (.info.json) with rich metadata. Test full import: 1) scan directory, 2) read metadata, 3) parse rich metadata, 4) store media file, 5) create tags/categories/performers, 6) create associations, 7) verify statistics. Test update scenario: import file, modify metadata JSON (change tags), re-import, verify associations updated (old removed, new added). Test error handling: create invalid metadata JSON, verify other files still import, verify error in statistics. Test statistics: verify tagsCreated, categoriesCreated, performersCreated counts are accurate. Test transactions: simulate database error during association creation, verify rollback (media file not created or rolled back). | Restrictions: Must use real test database (not mocks), clean database before each test (isolation), use transaction rollback for cleanup if possible, verify database state after operations (query tags/categories/performers tables), test both MySQL and PostgreSQL if supported, do not leave test data in database, limit test data size (few files, not hundreds), verify CASCADE DELETE works (delete media file, verify associations removed) | _Leverage: Study existing service integration tests for database setup patterns. Use e2e seed files as reference for test data structure | Success: Integration tests cover full import workflow, update scenarios verified, error handling works correctly, statistics are accurate, transactions are atomic, tests clean up after themselves, tests pass on both MySQL and PostgreSQL, CASCADE DELETE verified, tests are reliable and repeatable. After completing this task, mark task 11 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list test scenarios and database operations verified), then mark as [x] when complete.\n\n- [ ] 12. Update E2E tests for rich metadata\n  - File: backend/e2e/tests/media-loader.e2e.test.ts (enhance existing or create new)\n  - Add test data with .info.json files containing rich metadata\n  - Test querying media files by tags (via API)\n  - Test querying media files by categories (via API)\n  - Test querying media files by performers (via API)\n  - Test display names are returned correctly\n  - Test thumbnails and other metadata fields are returned\n  - Verify JOIN query performance (< 500ms for large dataset)\n  - Purpose: Validate API and query functionality\n  - _Leverage: backend/e2e/tests/ (existing E2E test patterns), backend/e2e/seed/init-db.sql_\n  - _Requirements: All requirements (user-facing validation)_\n  - _Prompt: Implement the task for spec rich-metadata-import, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Automation Engineer with expertise in E2E testing and API testing | Task: Create or enhance E2E tests to validate rich metadata functionality from API perspective. Prepare test data: create video files with corresponding .info.json metadata files with rich metadata. Test import via API or CLI: trigger MediaLoaderService, verify media files imported with metadata. Test API queries (assuming REST API exists or will exist): 1) GET /media-files?tag=brunette (verify returns correct files), 2) GET /media-files?category=HD Porn (verify correct files), 3) GET /media-files?performer=RavenPerformer (verify correct files), 4) GET /media-files/:uuid (verify returns tags/categories/performers arrays, display name, thumbnail, duration). Test query performance: import 100+ files, measure query time, verify < 500ms. Verify display names shown instead of UUIDs. | Restrictions: Must test through public API (not directly calling service methods), use realistic test data (similar to production metadata), measure and assert performance targets, clean up test data after tests, do not test internal implementation details, test user-facing functionality only, verify API returns expected JSON structure | _Leverage: Study existing E2E tests for API testing patterns. May need to create API endpoints if they don't exist yet (coordinate with API development) | Success: E2E tests validate full user workflow, API queries return correct results, filtering by tag/category/performer works, display names shown correctly, thumbnails and metadata returned, performance targets met (< 500ms queries), tests are reliable and clean up properly. After completing this task, mark task 12 as [-] in tasks.md, then use log-implementation tool with detailed artifacts (list E2E test scenarios and API endpoints tested), then mark as [x] when complete.\n",
  "fileStats": {
    "size": 31560,
    "lines": 173,
    "lastModified": "2025-11-10T14:55:43.730Z"
  },
  "comments": []
}