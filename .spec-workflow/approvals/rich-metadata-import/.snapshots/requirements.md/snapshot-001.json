{
  "id": "snapshot_1762785574723_5n4mo9bvi",
  "approvalId": "approval_1762785574719_xbhpmmr17",
  "approvalTitle": "Requirements Document - Rich Metadata Import",
  "version": 1,
  "timestamp": "2025-11-10T14:39:34.722Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe Rich Metadata Import feature enhances the existing media file metadata system to capture and store comprehensive metadata from video download sources. Currently, the system stores basic file information and generic JSON metadata. This enhancement will structure the metadata storage to support provider-specific information, categorization, tagging, thumbnail URLs, format details, and content creator information.\n\nThis feature enables users to:\n- Access rich metadata for each video file (tags, categories, descriptions)\n- View original source information (provider URLs, IDs)\n- Display thumbnails for video preview\n- Track video formats and quality options\n- Organize content by categories and tags\n- Associate videos with performers/creators\n\nThe enhanced metadata structure supports the existing UUID-based media file system while maintaining compatibility with the current `MediaLoaderService` workflow.\n\n## Alignment with Product Vision\n\nThis feature enhances the media management capabilities of the media-player system by:\n- **Improving Content Discovery**: Rich tagging and categorization enable better search and filtering\n- **Preserving Source Context**: Maintaining provider URLs and IDs enables content verification and re-downloading\n- **Enhancing User Experience**: Thumbnails provide visual preview before playback\n- **Supporting Content Organization**: Categories and tags enable logical grouping and playlists\n\n## Requirements\n\n### Requirement 1: Store Display Names\n\n**User Story:** As a media library manager, I want to store both the stored filename (UUID) and a human-readable display name, so that I can present user-friendly titles while maintaining unique file identifiers.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `display_name` field THEN the system SHALL store it in a dedicated database column\n2. WHEN a metadata file contains a `title` field and no `display_name` THEN the system SHALL use the title as the display name\n3. WHEN neither `display_name` nor `title` exists THEN the system SHALL use the filename without extension as the display name\n4. WHEN displaying media to users THEN the system SHALL show the display name, not the UUID filename\n\n### Requirement 2: Store Provider Information\n\n**User Story:** As a media library manager, I want to track which provider each video came from and its original source URL, so that I can verify content authenticity and re-download if needed.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `provider` field THEN the system SHALL store it as a string (e.g., \"pornhub\", \"youtube\")\n2. WHEN a metadata file contains an `id` field THEN the system SHALL store it as the provider's unique identifier for the video\n3. WHEN a metadata file contains a `webpage_url` field THEN the system SHALL store the original source URL\n4. WHEN querying media files THEN the system SHALL support filtering by provider\n\n### Requirement 3: Store Tags and Categories\n\n**User Story:** As a media library user, I want videos to be tagged and categorized based on their content, so that I can find related videos and organize my library.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `tags` array THEN the system SHALL store all tags as a JSON array\n2. WHEN a metadata file contains a `categories` array THEN the system SHALL store all categories as a JSON array\n3. WHEN a metadata file contains a `primary_tag` field THEN the system SHALL store it as the primary category\n4. WHEN querying media files THEN the system SHALL support filtering by tags (any match)\n5. WHEN querying media files THEN the system SHALL support filtering by categories (any match)\n6. WHEN querying media files THEN the system SHALL support filtering by primary tag (exact match)\n\n### Requirement 4: Store Thumbnail Information\n\n**User Story:** As a media library user, I want to see thumbnail previews of videos, so that I can visually identify content before playing.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `thumbnail` field THEN the system SHALL store the thumbnail URL\n2. WHEN a metadata file contains multiple thumbnail URLs THEN the system SHALL store the highest quality thumbnail\n3. WHEN retrieving media file information THEN the system SHALL include the thumbnail URL in the response\n4. IF a thumbnail URL is stored THEN the system SHALL validate it is a valid URL format\n\n### Requirement 5: Store Duration Information\n\n**User Story:** As a media library user, I want to see how long each video is, so that I can plan my viewing time.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `duration` field in seconds THEN the system SHALL store it as an integer\n2. WHEN displaying duration THEN the system SHALL format it as HH:MM:SS for readability\n3. WHEN querying media files THEN the system SHALL support filtering by duration range (min/max)\n\n### Requirement 6: Store Format Information\n\n**User Story:** As a media library manager, I want to track which video format was downloaded and what formats were available, so that I can understand quality and re-download higher quality versions if needed.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `formats` array THEN the system SHALL store all available formats as a JSON array\n2. WHEN a metadata file contains a `downloaded_format` field THEN the system SHALL store which format was actually downloaded\n3. WHEN a metadata file contains a `format` field (singular) THEN the system SHALL store it as the downloaded format\n4. WHEN querying media files THEN the system SHALL support filtering by downloaded format\n\n### Requirement 7: Store Performer/Creator Information\n\n**User Story:** As a media library user, I want to see which performers or creators are featured in each video, so that I can find more content from the same people.\n\n#### Acceptance Criteria\n\n1. WHEN a metadata file contains a `pornstars` array THEN the system SHALL store it as a JSON array (even if empty)\n2. WHEN a metadata file contains a `creators` or `uploader` field THEN the system SHALL store creator information\n3. WHEN querying media files THEN the system SHALL support filtering by performer/creator name\n4. WHEN the performers array is empty THEN the system SHALL store an empty array, not null\n\n### Requirement 8: Update Existing Records\n\n**User Story:** As a media library manager, I want the metadata import process to update existing records when new metadata is found, so that my library stays current without duplicating entries.\n\n#### Acceptance Criteria\n\n1. WHEN importing metadata for an existing UUID THEN the system SHALL update the existing record, not create a duplicate\n2. WHEN updating a record THEN the system SHALL only update fields that have changed\n3. WHEN updating a record THEN the system SHALL update the `updated_at` timestamp\n4. WHEN updating a record THEN the system SHALL update the `last_scanned_at` timestamp\n5. IF metadata has not changed THEN the system SHALL only update `last_scanned_at`, not `updated_at`\n\n### Requirement 9: Handle Missing Metadata Gracefully\n\n**User Story:** As a media library manager, I want the system to handle incomplete metadata gracefully, so that videos with partial metadata can still be imported and used.\n\n#### Acceptance Criteria\n\n1. WHEN a required field is missing from metadata THEN the system SHALL use a sensible default value\n2. WHEN an optional field is missing from metadata THEN the system SHALL store NULL or an empty value as appropriate\n3. WHEN metadata parsing fails THEN the system SHALL log the error and continue processing other files\n4. WHEN metadata JSON is malformed THEN the system SHALL log the error with the file path and continue\n\n### Requirement 10: Maintain Backward Compatibility\n\n**User Story:** As a system administrator, I want the new metadata schema to be backward compatible with existing data, so that my current media library continues to work during and after the upgrade.\n\n#### Acceptance Criteria\n\n1. WHEN the new schema is deployed THEN existing `media_files` records SHALL remain valid and accessible\n2. WHEN migrating the database THEN the system SHALL add new columns with NULL defaults\n3. WHEN querying legacy records THEN the system SHALL return NULL for fields that don't have values\n4. WHEN the MediaLoaderService runs THEN it SHALL process both old and new metadata formats\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Metadata parsing logic should be separate from database operations\n- **Modular Design**: Create reusable metadata validator and transformer utilities\n- **Dependency Management**: Keep database adapter changes isolated from service layer logic\n- **Clear Interfaces**: Define TypeScript interfaces for the enhanced metadata structure\n\n### Performance\n- **Import Speed**: The enhanced metadata import should not significantly slow down the existing MediaLoaderService batch processing\n- **Query Performance**: Database queries filtering by tags, categories, or performers should complete in under 500ms for libraries up to 100,000 videos\n- **Batch Size**: Maintain the existing batch size of 100 files per transaction\n- **Index Strategy**: Add appropriate database indexes for new filterable fields without over-indexing\n\n### Security\n- **URL Validation**: Validate thumbnail URLs and webpage URLs to prevent injection attacks\n- **Input Sanitization**: Sanitize all metadata text fields before storing to prevent XSS\n- **SQL Injection Prevention**: Use parameterized queries for all database operations (already enforced by DatabaseAdapter)\n- **File Path Validation**: Validate stored paths are within expected directories\n\n### Reliability\n- **Error Recovery**: Metadata parsing errors for one file should not stop processing of other files\n- **Transaction Safety**: Database updates should be transactional (rollback on failure)\n- **Idempotency**: Re-importing metadata for the same file should produce consistent results\n- **Data Integrity**: Foreign key constraints and data type validation should prevent invalid data\n\n### Usability\n- **Clear Error Messages**: When metadata import fails, provide clear error messages with file paths and reasons\n- **Progress Tracking**: Maintain existing statistics reporting (files processed, errors, etc.)\n- **Dry-Run Mode**: Support dry-run mode to preview changes before applying them\n- **Logging Verbosity**: Support verbose logging mode for debugging import issues\n",
  "fileStats": {
    "size": 10516,
    "lines": 170,
    "lastModified": "2025-11-10T14:39:26.753Z"
  },
  "comments": []
}