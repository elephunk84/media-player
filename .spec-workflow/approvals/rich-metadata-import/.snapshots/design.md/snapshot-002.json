{
  "id": "snapshot_1762786378946_t55yfytam",
  "approvalId": "approval_1762786311070_39hmlzpcu",
  "approvalTitle": "Design Document - Rich Metadata Import",
  "version": 2,
  "timestamp": "2025-11-10T14:52:58.946Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Rich Metadata Import feature enhances the existing media file metadata system by implementing a normalized database schema for tags, categories, and performers. This design replaces the current generic JSON metadata storage with structured relational tables that enable efficient querying and filtering.\n\nThe system will:\n- Create four new normalized tables: `tags`, `categories`, `performers`, and three junction tables\n- Add metadata-specific columns to the `media_files` table (display_name, provider, thumbnail, duration, etc.)\n- Enhance the `MediaLoaderService` to parse rich metadata and populate these tables\n- Maintain backward compatibility with existing media files\n- Support both MySQL and PostgreSQL databases\n\nThis design integrates with the existing UUID-based media file system and preserves the current batch import workflow.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\nNo steering documents exist for this project. This design follows TypeScript best practices and maintains consistency with the existing codebase patterns.\n\n### Project Structure (structure.md)\nThe implementation follows the existing project structure:\n- Database migrations in `backend/src/migrations/`\n- Database adapters in `backend/src/adapters/`\n- Models in `backend/src/models/`\n- Services in `backend/src/services/`\n- Utilities in `backend/src/utils/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **DatabaseAdapter (MySQLAdapter, PostgreSQLAdapter)**: Will be used for all database operations. Supports parameterized queries and transactions.\n- **MigrationRunner**: Will execute the new migration to create tables and add columns.\n- **MediaLoaderService**: Will be enhanced to parse rich metadata and populate normalized tables.\n- **MetadataReader**: Already reads `.info.json` files. Will be used without modification.\n- **UUIDExtractor**: Already extracts UUIDs from filenames. Will be used without modification.\n- **FileScanner**: Already scans directories for video files. Will be used without modification.\n\n### Integration Points\n\n- **media_files table**: New columns will be added via migration. Existing records remain valid.\n- **MediaLoaderService batch processing**: Will be extended to handle tag/category/performer associations after inserting media file records.\n- **Database transaction support**: Will use existing transaction methods for atomic operations.\n- **Error handling and statistics**: Will extend existing statistics tracking in `LoaderStatistics` interface.\n\n## Architecture\n\nThe architecture follows a layered approach with clear separation of concerns:\n\n1. **Data Layer**: Database adapters handle all SQL operations\n2. **Migration Layer**: Versioned migrations create/update schema\n3. **Model Layer**: TypeScript interfaces define data structures\n4. **Service Layer**: MediaLoaderService orchestrates import workflow\n5. **Utility Layer**: Metadata parsing and validation utilities\n\n### Modular Design Principles\n\n- **Single File Responsibility**: Each utility handles one specific concern (tag management, category management, performer management)\n- **Component Isolation**: New tag/category/performer management utilities are independent modules\n- **Service Layer Separation**: MediaLoaderService coordinates but delegates to specialized utilities\n- **Utility Modularity**: Create focused utilities for metadata parsing, validation, and normalization\n\n```mermaid\ngraph TD\n    A[MediaLoaderService] --> B[MetadataReader]\n    A --> C[DatabaseAdapter]\n    A --> D[TagManager]\n    A --> E[CategoryManager]\n    A --> F[PerformerManager]\n    A --> G[MetadataParser]\n\n    D --> C\n    E --> C\n    F --> C\n\n    G --> H[MetadataValidator]\n\n    C --> I[MySQLAdapter]\n    C --> J[PostgreSQLAdapter]\n\n    style A fill:#e1f5e1\n    style D fill:#fff4e6\n    style E fill:#fff4e6\n    style F fill:#fff4e6\n    style G fill:#e3f2fd\n```\n\n## Components and Interfaces\n\n### Component 1: Migration 003 - Rich Metadata Schema\n\n- **Purpose:** Create normalized tables for tags, categories, performers and add columns to media_files\n- **Location:** `backend/src/migrations/003_rich_metadata_schema.ts`\n- **Tables Created:**\n  - `tags` (id, name, created_at, updated_at)\n  - `categories` (id, name, created_at, updated_at)\n  - `performers` (id, name, created_at, updated_at)\n  - `media_file_tags` (media_file_uuid, tag_id)\n  - `media_file_categories` (media_file_uuid, category_id)\n  - `media_file_performers` (media_file_uuid, performer_id)\n- **Columns Added to media_files:**\n  - `display_name` VARCHAR(255)\n  - `provider` VARCHAR(100)\n  - `provider_id` VARCHAR(255)\n  - `webpage_url` VARCHAR(512)\n  - `thumbnail` VARCHAR(512)\n  - `duration` INT\n  - `downloaded_format` VARCHAR(50)\n  - `available_formats` JSON/JSONB\n  - `creator` VARCHAR(255)\n  - `primary_tag_id` INT (FK to tags.id)\n- **Indexes:** All foreign key columns, name columns with case-insensitive unique constraints\n- **Dependencies:** DatabaseAdapter\n- **Reuses:** MigrationRunner, existing migration pattern\n\n### Component 2: TagManager Utility\n\n- **Purpose:** Manage tag CRUD operations and media file associations\n- **Location:** `backend/src/utils/TagManager.ts`\n- **Interfaces:**\n  - `findOrCreateTag(name: string): Promise<number>` - Returns tag ID\n  - `findOrCreateTags(names: string[]): Promise<number[]>` - Batch operation\n  - `associateTagsWithMediaFile(uuid: string, tagIds: number[]): Promise<void>`\n  - `getTagsForMediaFile(uuid: string): Promise<Tag[]>`\n  - `removeMediaFileAssociations(uuid: string): Promise<void>`\n  - `syncMediaFileTags(uuid: string, tagNames: string[]): Promise<void>` - Full sync (add new, remove old)\n- **Dependencies:** DatabaseAdapter\n- **Reuses:** Database transaction support for atomic operations\n\n### Component 3: CategoryManager Utility\n\n- **Purpose:** Manage category CRUD operations and media file associations\n- **Location:** `backend/src/utils/CategoryManager.ts`\n- **Interfaces:**\n  - `findOrCreateCategory(name: string): Promise<number>` - Returns category ID\n  - `findOrCreateCategories(names: string[]): Promise<number[]>` - Batch operation\n  - `associateCategoriesWithMediaFile(uuid: string, categoryIds: number[]): Promise<void>`\n  - `getCategoriesForMediaFile(uuid: string): Promise<Category[]>`\n  - `removeMediaFileAssociations(uuid: string): Promise<void>`\n  - `syncMediaFileCategories(uuid: string, categoryNames: string[]): Promise<void>` - Full sync\n- **Dependencies:** DatabaseAdapter\n- **Reuses:** Database transaction support\n\n### Component 4: PerformerManager Utility\n\n- **Purpose:** Manage performer CRUD operations and media file associations\n- **Location:** `backend/src/utils/PerformerManager.ts`\n- **Interfaces:**\n  - `findOrCreatePerformer(name: string): Promise<number>` - Returns performer ID\n  - `findOrCreatePerformers(names: string[]): Promise<number[]>` - Batch operation\n  - `associatePerformersWithMediaFile(uuid: string, performerIds: number[]): Promise<void>`\n  - `getPerformersForMediaFile(uuid: string): Promise<Performer[]>`\n  - `removeMediaFileAssociations(uuid: string): Promise<void>`\n  - `syncMediaFilePerformers(uuid: string, performerNames: string[]): Promise<void>` - Full sync\n- **Dependencies:** DatabaseAdapter\n- **Reuses:** Database transaction support\n\n### Component 5: MetadataParser Utility\n\n- **Purpose:** Parse and validate rich metadata from .info.json files\n- **Location:** `backend/src/utils/MetadataParser.ts`\n- **Interfaces:**\n  - `parseRichMetadata(rawMetadata: any): ParsedRichMetadata` - Extracts structured metadata\n  - `extractDisplayName(metadata: any): string` - display_name > title > filename fallback\n  - `extractTags(metadata: any): string[]` - Normalizes tag names\n  - `extractCategories(metadata: any): string[]` - Normalizes category names\n  - `extractPerformers(metadata: any): string[]` - Extracts from pornstars array\n  - `extractProviderInfo(metadata: any): ProviderInfo` - provider, id, webpage_url\n  - `extractThumbnail(metadata: any): string | null` - Validates URL\n  - `extractDuration(metadata: any): number | null` - Validates integer\n  - `extractFormats(metadata: any): FormatInfo` - available_formats, downloaded_format\n  - `validateMetadata(metadata: ParsedRichMetadata): ValidationResult` - Returns errors/warnings\n- **Dependencies:** None (pure utility)\n- **Reuses:** Existing metadata reading patterns from MetadataReader\n\n### Component 6: Enhanced MediaLoaderService\n\n- **Purpose:** Orchestrate rich metadata import workflow\n- **Location:** `backend/src/services/MediaLoaderService.ts` (existing file, will be enhanced)\n- **New Methods:**\n  - `private async processRichMetadata(uuid: string, metadata: any): Promise<void>` - Parses and stores rich metadata\n  - `private async syncAssociations(uuid: string, parsed: ParsedRichMetadata): Promise<void>` - Updates tag/category/performer associations\n- **Enhanced Methods:**\n  - `storeMediaFiles()` - Will call `processRichMetadata()` after storing basic media file info\n- **Dependencies:** DatabaseAdapter, MetadataParser, TagManager, CategoryManager, PerformerManager\n- **Reuses:** Existing batch processing, transaction support, error handling, statistics tracking\n\n## Data Models\n\n### Database Tables\n\n#### tags Table\n```sql\nCREATE TABLE tags (\n  id INT/SERIAL PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  UNIQUE KEY idx_name_unique (name) -- Case-insensitive\n);\nCREATE INDEX idx_name ON tags(name);\n```\n\n#### categories Table\n```sql\nCREATE TABLE categories (\n  id INT/SERIAL PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  UNIQUE KEY idx_name_unique (name) -- Case-insensitive\n);\nCREATE INDEX idx_name ON categories(name);\n```\n\n#### performers Table\n```sql\nCREATE TABLE performers (\n  id INT/SERIAL PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  UNIQUE KEY idx_name_unique (name) -- Case-insensitive\n);\nCREATE INDEX idx_name ON performers(name);\n```\n\n#### media_file_tags Junction Table\n```sql\nCREATE TABLE media_file_tags (\n  media_file_uuid VARCHAR(36) NOT NULL,\n  tag_id INT NOT NULL,\n  PRIMARY KEY (media_file_uuid, tag_id),\n  FOREIGN KEY (media_file_uuid) REFERENCES media_files(uuid) ON DELETE CASCADE,\n  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE\n);\nCREATE INDEX idx_media_file_uuid ON media_file_tags(media_file_uuid);\nCREATE INDEX idx_tag_id ON media_file_tags(tag_id);\n```\n\n#### media_file_categories Junction Table\n```sql\nCREATE TABLE media_file_categories (\n  media_file_uuid VARCHAR(36) NOT NULL,\n  category_id INT NOT NULL,\n  PRIMARY KEY (media_file_uuid, category_id),\n  FOREIGN KEY (media_file_uuid) REFERENCES media_files(uuid) ON DELETE CASCADE,\n  FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE\n);\nCREATE INDEX idx_media_file_uuid ON media_file_categories(media_file_uuid);\nCREATE INDEX idx_category_id ON media_file_categories(category_id);\n```\n\n#### media_file_performers Junction Table\n```sql\nCREATE TABLE media_file_performers (\n  media_file_uuid VARCHAR(36) NOT NULL,\n  performer_id INT NOT NULL,\n  PRIMARY KEY (media_file_uuid, performer_id),\n  FOREIGN KEY (media_file_uuid) REFERENCES media_files(uuid) ON DELETE CASCADE,\n  FOREIGN KEY (performer_id) REFERENCES performers(id) ON DELETE CASCADE\n);\nCREATE INDEX idx_media_file_uuid ON media_file_performers(media_file_uuid);\nCREATE INDEX idx_performer_id ON media_file_performers(performer_id);\n```\n\n#### Enhanced media_files Table\n```sql\nALTER TABLE media_files\n  ADD COLUMN display_name VARCHAR(255),\n  ADD COLUMN provider VARCHAR(100),\n  ADD COLUMN provider_id VARCHAR(255),\n  ADD COLUMN webpage_url VARCHAR(512),\n  ADD COLUMN thumbnail VARCHAR(512),\n  ADD COLUMN duration INT,\n  ADD COLUMN downloaded_format VARCHAR(50),\n  ADD COLUMN available_formats JSON/JSONB,\n  ADD COLUMN creator VARCHAR(255),\n  ADD COLUMN primary_tag_id INT,\n  ADD FOREIGN KEY (primary_tag_id) REFERENCES tags(id) ON DELETE SET NULL;\n\nCREATE INDEX idx_display_name ON media_files(display_name);\nCREATE INDEX idx_provider ON media_files(provider);\nCREATE INDEX idx_duration ON media_files(duration);\nCREATE INDEX idx_primary_tag_id ON media_files(primary_tag_id);\n```\n\n### TypeScript Interfaces\n\n#### Tag Model\n```typescript\ninterface Tag {\n  readonly id: number;\n  name: string;\n  readonly createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n#### Category Model\n```typescript\ninterface Category {\n  readonly id: number;\n  name: string;\n  readonly createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n#### Performer Model\n```typescript\ninterface Performer {\n  readonly id: number;\n  name: string;\n  readonly createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n#### Enhanced MediaFile Model\n```typescript\ninterface MediaFile {\n  readonly uuid: string;\n  filePath: string;\n  fileName: string;\n  fileSize: number | null;\n  fileExtension: string | null;\n\n  // New rich metadata fields\n  displayName: string | null;\n  provider: string | null;\n  providerId: string | null;\n  webpageUrl: string | null;\n  thumbnail: string | null;\n  duration: number | null;\n  downloadedFormat: string | null;\n  availableFormats: string[] | null;\n  creator: string | null;\n  primaryTagId: number | null;\n\n  // Existing fields\n  metadata: Record<string, unknown> | null;\n  metadataFilePath: string | null;\n  readonly createdAt: Date;\n  updatedAt: Date;\n  lastScannedAt: Date;\n\n  // Virtual associations (populated via JOIN)\n  tags?: Tag[];\n  categories?: Category[];\n  performers?: Performer[];\n}\n```\n\n#### ParsedRichMetadata Interface\n```typescript\ninterface ParsedRichMetadata {\n  displayName: string;\n  provider: string | null;\n  providerId: string | null;\n  webpageUrl: string | null;\n  thumbnail: string | null;\n  duration: number | null;\n  downloadedFormat: string | null;\n  availableFormats: string[];\n  creator: string | null;\n  primaryTag: string | null;\n  tags: string[];\n  categories: string[];\n  performers: string[];\n}\n```\n\n#### ProviderInfo Interface\n```typescript\ninterface ProviderInfo {\n  provider: string | null;\n  providerId: string | null;\n  webpageUrl: string | null;\n}\n```\n\n#### FormatInfo Interface\n```typescript\ninterface FormatInfo {\n  downloadedFormat: string | null;\n  availableFormats: string[];\n}\n```\n\n#### ValidationResult Interface\n```typescript\ninterface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n```\n\n#### Enhanced LoaderStatistics Interface\n```typescript\ninterface LoaderStatistics {\n  // Existing fields\n  filesScanned: number;\n  filesProcessed: number;\n  filesWithUUID: number;\n  filesWithoutUUID: number;\n  filesWithMetadata: number;\n  filesWithoutMetadata: number;\n  recordsInserted: number;\n  recordsUpdated: number;\n  recordsUnchanged: number;\n  errors: number;\n  errorMessages: string[];\n  startTime: Date;\n  endTime?: Date;\n  durationMs?: number;\n\n  // New fields for rich metadata\n  tagsCreated: number;\n  categoriesCreated: number;\n  performersCreated: number;\n  associationsCreated: number;\n  associationsRemoved: number;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Malformed Metadata JSON**\n   - **Handling:** Catch parsing error, log with file path, continue processing other files\n   - **User Impact:** File imported with basic info only (no rich metadata), error logged in statistics\n\n2. **Database Constraint Violation (Unique Name)**\n   - **Handling:** Catch duplicate key error, fetch existing record by name, use existing ID\n   - **User Impact:** Tag/category/performer reused (expected behavior), no user-visible error\n\n3. **Foreign Key Constraint Violation**\n   - **Handling:** Log error, skip association creation, continue with other associations\n   - **User Impact:** Some associations may be missing, error logged in statistics\n\n4. **Invalid URL Format (Thumbnail/Webpage URL)**\n   - **Handling:** Validate URL using regex, store NULL if invalid, log warning\n   - **User Impact:** No thumbnail displayed, URL field empty, warning in logs\n\n5. **Invalid Duration Value (Non-numeric)**\n   - **Handling:** Validate type, use NULL if invalid, log warning\n   - **User Impact:** Duration not displayed, warning in logs\n\n6. **Transaction Rollback Failure**\n   - **Handling:** Log critical error, halt batch processing, report to user\n   - **User Impact:** Batch import stops, user notified to check database state\n\n7. **Case-Insensitive Duplicate Handling**\n   - **Handling:** Use LOWER(name) in unique constraint, normalize names to lowercase before insert\n   - **User Impact:** \"Action\" and \"action\" treated as same tag/category\n\n8. **Missing Required Fields in Metadata**\n   - **Handling:** Use sensible defaults (display_name defaults to title or filename)\n   - **User Impact:** File imported successfully with fallback values\n\n9. **Orphaned Tags/Categories/Performers**\n   - **Handling:** Optional cleanup job to remove records with no associations\n   - **User Impact:** None (internal database cleanup)\n\n10. **Primary Tag Not in Tags Array**\n    - **Handling:** If primary_tag not found in tags array, create tag and add to associations\n    - **User Impact:** Primary tag always appears in tags list\n\n## Testing Strategy\n\n### Unit Testing\n\n**Test Files:**\n- `TagManager.test.ts` - Test tag CRUD operations, duplicate handling, case-insensitive matching\n- `CategoryManager.test.ts` - Test category CRUD operations, duplicate handling\n- `PerformerManager.test.ts` - Test performer CRUD operations, duplicate handling\n- `MetadataParser.test.ts` - Test parsing logic, fallback values, validation\n\n**Key Tests:**\n- Case-insensitive tag/category/performer matching (\"Action\" vs \"action\")\n- Duplicate detection and reuse\n- NULL handling for optional fields\n- Array parsing and normalization\n- URL validation\n- Duration validation\n- Display name fallback logic (display_name > title > filename)\n- Empty array handling\n\n### Integration Testing\n\n**Test Files:**\n- `MediaLoaderService.integration.test.ts` - Test full import workflow with rich metadata\n\n**Key Flows:**\n1. Import new media file with full rich metadata\n2. Update existing media file with changed tags/categories/performers\n3. Import media file with minimal metadata (test defaults)\n4. Import batch of files with mixed metadata completeness\n5. Verify transaction rollback on error\n6. Verify associations are created correctly\n7. Verify associations are removed when metadata changes\n8. Verify case-insensitive matching works\n\n### End-to-End Testing\n\n**Test Scenarios:**\n1. **Full Import Workflow:**\n   - Scan directory with video files\n   - Read .info.json metadata files\n   - Parse rich metadata\n   - Create database records\n   - Verify all associations created\n   - Verify query performance\n\n2. **Update Workflow:**\n   - Import files\n   - Modify metadata files (add/remove tags)\n   - Re-import\n   - Verify associations updated correctly\n\n3. **Error Recovery:**\n   - Import with malformed metadata\n   - Verify other files still imported\n   - Verify statistics report errors correctly\n\n4. **Query Performance:**\n   - Import 1,000+ files with tags/categories/performers\n   - Query by tag (should use JOIN, not JSON parsing)\n   - Query by category (should use JOIN)\n   - Query by performer (should use JOIN)\n   - Verify queries complete in < 500ms\n\n5. **Migration Testing:**\n   - Run migration on empty database\n   - Run migration on database with existing media_files\n   - Verify backward compatibility\n   - Verify foreign key constraints work\n\n## Migration Strategy\n\n### Migration Execution Order\n\n1. **Create normalized tables** (tags, categories, performers)\n2. **Create junction tables** (media_file_tags, media_file_categories, media_file_performers)\n3. **Add columns to media_files table**\n4. **Create indexes** for performance\n5. **Add foreign key constraints** (with CASCADE DELETE)\n\n### Rollback Strategy\n\n- Migration includes `down()` method to drop tables and columns\n- Transaction-based execution ensures atomicity\n- Test rollback on staging environment before production deployment\n\n### Data Migration\n\n- Existing `media_files` records remain valid (new columns default to NULL)\n- No data migration needed initially\n- Next import run will populate rich metadata for existing files\n\n## Performance Considerations\n\n### Query Optimization\n\n- **Indexes:** All foreign key columns indexed for JOIN performance\n- **Unique Constraints:** Enable fast lookups when checking for existing tags/categories/performers\n- **Batch Inserts:** Use batch operations for junction table inserts (reduce round trips)\n\n### Batch Processing\n\n- Maintain existing batch size of 100 files per transaction\n- Process associations after media file insert (same transaction)\n- Use `findOrCreateTags()` batch method instead of individual calls\n\n### Memory Management\n\n- Keep tag/category/performer names in memory during batch (cache for deduplication)\n- Clear cache after each batch to prevent memory growth\n- Limit metadata JSON size (warn if > 1MB)\n\n### Expected Performance\n\n- **Import Speed:** < 10 seconds for 100 files with rich metadata\n- **Query Speed:** < 500ms for filtering 100,000 files by tag/category/performer\n- **Database Growth:** ~3-5 new rows per media file (tags + categories + performers)\n\n## Database-Specific Considerations\n\n### MySQL\n\n- Use `AUTO_INCREMENT` for primary keys\n- Use `JSON` type for available_formats\n- Use `ON UPDATE CURRENT_TIMESTAMP` for updated_at\n- Use `LOWER()` function for case-insensitive unique constraints\n\n### PostgreSQL\n\n- Use `SERIAL` for primary keys\n- Use `JSONB` type for available_formats (better query performance)\n- Use trigger for updated_at timestamp\n- Use `CITEXT` extension or `LOWER()` for case-insensitive unique constraints\n\n## Security Considerations\n\n- **SQL Injection Prevention:** Use parameterized queries (enforced by DatabaseAdapter)\n- **URL Validation:** Validate thumbnail and webpage URLs before storing\n- **Input Sanitization:** Trim and normalize tag/category/performer names\n- **Path Validation:** Ensure metadata file paths are within expected directory\n",
  "fileStats": {
    "size": 22259,
    "lines": 613,
    "lastModified": "2025-11-10T14:51:42.861Z"
  },
  "comments": []
}