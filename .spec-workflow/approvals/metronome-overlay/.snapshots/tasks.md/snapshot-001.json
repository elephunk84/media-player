{
  "id": "snapshot_1762768249794_nf30zlsfq",
  "approvalId": "approval_1762768249791_ecuwh6hmo",
  "approvalTitle": "Tasks Document - Metronome Overlay Implementation Guide",
  "version": 1,
  "timestamp": "2025-11-10T09:50:49.794Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Phase 1: Type Definitions and Data Models\n\n- [ ] 1. Create metronome TypeScript interfaces\n  - File: `frontend/src/types/metronome.ts`\n  - Define all TypeScript interfaces for metronome configuration, patterns, audio, visual, and presets\n  - Create discriminated unions for visual config types\n  - Purpose: Establish type safety for entire metronome system\n  - _Leverage: `frontend/src/types/video.ts` for naming conventions and patterns\n  - _Requirements: REQ-1 (Basic Metronome), REQ-3 (Patterns), REQ-5 (Visual), REQ-6 (Audio), REQ-8 (Presets)\n  - _Prompt:\n    ```\n    Role: TypeScript Developer specializing in type systems and interfaces\n\n    Task: Create comprehensive TypeScript interfaces in frontend/src/types/metronome.ts for the metronome overlay system. You need to implement interfaces for:\n\n    1. MetronomeConfig - Main configuration interface with:\n       - bpm (number, 30-300 range)\n       - enabled (boolean)\n       - pattern settings (BeatPattern interface)\n       - randomization settings (number 0-50)\n       - tempo change settings (TempoChangeConfig interface)\n       - audio settings (AudioConfig interface)\n       - visual settings (VisualConfig interface)\n       - sync options (syncToVideo, continuousMode booleans)\n\n    2. BeatPattern - Pattern definition with:\n       - beats array of BeatIntensity type ('light' | 'medium' | 'strong' | 'silent')\n       - length (number 2-32)\n       - accentBeat (number | null)\n\n    3. BeatInfo - Internal beat information with:\n       - beatNumber, intensity, volume, timestamp\n\n    4. TempoChangeConfig - Tempo change configuration with:\n       - mode ('accelerate' | 'decelerate' | 'cycle')\n       - changePerMinute, minBPM, maxBPM, resetOnStop\n\n    5. AudioConfig - Audio settings with:\n       - soundType ('click' | 'beep' | 'drum' | 'snap' | 'woodblock' | 'custom')\n       - customSoundUrl, masterVolume, muted\n       - volumeVariation and volumeMap for intensity-based volumes\n\n    6. VisualConfig - Visual settings using discriminated unions:\n       - Common: enabled, color, opacity\n       - Style-specific: visualStyle as discriminator\n       - Different properties for 'flash', 'pulse', 'border', 'none'\n\n    7. Position - Position configuration with preset or custom x/y\n\n    8. MetronomePreset - Saved preset with id, name, description, config, timestamps\n\n    9. MetronomeState - Runtime state tracking\n\n    Restrictions:\n    - Must use exact type names specified above\n    - Follow existing patterns from frontend/src/types/video.ts\n    - Use discriminated unions for VisualConfig to enable type narrowing\n    - Add JSDoc comments for all interfaces and properties\n    - Export all interfaces\n\n    Success: All interfaces compile without errors, discriminated unions enable proper type narrowing, comprehensive JSDoc documentation, follows project type conventions\n    ```\n\n## Phase 2: Core Timing Engine\n\n- [ ] 2.1. Create timing calculation utilities\n  - File: `frontend/src/utils/metronome/timingCalculations.ts`\n  - Implement pure functions for BPM↔milliseconds conversion, beat duration with randomization, tempo changes\n  - Purpose: Provide math utilities for timing engine\n  - _Leverage: None (foundational utility)\n  - _Requirements: REQ-1 (Basic Metronome), REQ-4 (Timing Controls)\n  - _Prompt:\n    ```\n    Role: Software Engineer specializing in timing algorithms and mathematics\n\n    Task: Create timing calculation utilities in frontend/src/utils/metronome/timingCalculations.ts. Implement these pure functions:\n\n    1. bpmToMilliseconds(bpm: number): number\n       - Convert BPM to milliseconds per beat\n       - Formula: (60 / bpm) * 1000\n       - Validate BPM range 30-300\n\n    2. millisecondsToBPM(ms: number): number\n       - Convert milliseconds to BPM\n       - Inverse of above formula\n\n    3. calculateBeatDuration(bpm: number, randomization: number): number\n       - Calculate beat duration with optional randomization\n       - randomization is percentage (0-50)\n       - Apply random variation within ±randomization%\n\n    4. applyTempoChange(currentBPM: number, config: TempoChangeConfig, elapsedMinutes: number): number\n       - Calculate new BPM based on tempo change config\n       - Handle accelerate/decelerate/cycle modes\n       - Respect minBPM and maxBPM bounds\n       - For cycle mode: oscillate between min and max\n\n    5. calculateBeatFromTime(timeSeconds: number, bpm: number): number\n       - Calculate which beat number should be playing at given time\n       - Used for video seek synchronization\n\n    6. validateBPM(bpm: number): boolean\n       - Validate BPM is in range 30-300\n\n    Restrictions:\n    - All functions must be pure (no side effects)\n    - Add input validation for all parameters\n    - Include unit test examples in JSDoc comments\n    - Handle edge cases (division by zero, negative values)\n    - Use precise floating-point math\n\n    Leverage: Import types from frontend/src/types/metronome.ts\n\n    Success: All functions are pure and testable, comprehensive input validation, JSDoc with examples, handles edge cases gracefully\n    ```\n\n- [ ] 2.2. Create MetronomeEngine core class\n  - File: `frontend/src/services/metronome/MetronomeEngine.ts`\n  - Implement core timing engine using Web Audio API with look-ahead scheduling\n  - Add event emitter for beat notifications\n  - Purpose: Provide high-precision beat timing independent of React\n  - _Leverage: `frontend/src/utils/metronome/timingCalculations.ts`\n  - _Requirements: REQ-1 (Basic Metronome), REQ-3 (Patterns), REQ-10 (Performance)\n  - _Prompt:\n    ```\n    Role: Senior JavaScript Developer with expertise in Web Audio API and timing systems\n\n    Task: Create MetronomeEngine class in frontend/src/services/metronome/MetronomeEngine.ts using Web Audio API for precise timing. This is pure TypeScript with NO React dependencies.\n\n    Architecture:\n    - Use look-ahead scheduling pattern: schedule beats ~100ms in advance\n    - Use AudioContext.currentTime for sample-accurate scheduling\n    - Use setTimeout to wake scheduler every 25ms to check for beats to schedule\n    - Emit 'beat' events when beats occur\n\n    Class structure:\n\n    ```typescript\n    export class MetronomeEngine {\n      private audioContext: AudioContext | null = null;\n      private schedulerTimer: number | null = null;\n      private nextBeatTime: number = 0;\n      private currentBeatInPattern: number = 0;\n      private config: MetronomeConfig | null = null;\n      private beatListeners: Array<(info: BeatInfo) => void> = [];\n      private isRunning: boolean = false;\n\n      constructor() {\n        // Initialize AudioContext (handle prefixes for Safari)\n      }\n\n      start(config: MetronomeConfig): void {\n        // Start the metronome with given config\n        // Initialize audioContext if needed\n        // Set up first beat time\n        // Start scheduler loop\n      }\n\n      stop(): void {\n        // Stop metronome completely\n        // Clear scheduler timer\n        // Reset state\n      }\n\n      pause(): void {\n        // Pause without resetting state\n      }\n\n      resume(): void {\n        // Resume from pause\n      }\n\n      updateBPM(bpm: number): void {\n        // Update BPM in real-time\n        // Recalculate next beat timing\n      }\n\n      updatePattern(pattern: BeatPattern): void {\n        // Update pattern configuration\n      }\n\n      seekToBeat(beatNumber: number): void {\n        // Jump to specific beat in pattern\n        // Used for video seek synchronization\n      }\n\n      on(event: 'beat', callback: (info: BeatInfo) => void): void {\n        // Subscribe to beat events\n      }\n\n      off(event: 'beat', callback: (info: BeatInfo) => void): void {\n        // Unsubscribe from beat events\n      }\n\n      getCurrentBeat(): number {\n        // Get current beat number in pattern\n      }\n\n      dispose(): void {\n        // Clean up resources\n        // Close AudioContext\n        // Clear all listeners\n      }\n\n      private scheduleBeats(): void {\n        // Core scheduling logic\n        // Schedule all beats in next 100ms window\n        // Calculate which beat in pattern\n        // Get intensity from pattern\n        // Emit beat event at correct time\n        // Schedule next check\n      }\n\n      private getNextBeatInfo(): BeatInfo {\n        // Calculate next beat information\n        // Get intensity from pattern array\n        // Apply randomization if enabled\n        // Apply tempo changes if enabled\n      }\n    }\n    ```\n\n    Key implementation details:\n    1. Use `const AudioContextClass = window.AudioContext || window.webkitAudioContext` for Safari\n    2. In scheduleBeats(), schedule all beats where `nextBeatTime < audioContext.currentTime + 0.1`\n    3. Emit beat events using setTimeout aligned to Web Audio clock\n    4. Track beat position in pattern, wrap around when reaching pattern.length\n    5. Apply randomization from timingCalculations.calculateBeatDuration\n    6. Handle tempo changes by recalculating intervals\n\n    Restrictions:\n    - NO React dependencies (must be pure TypeScript)\n    - Must maintain <±5ms timing accuracy\n    - Must gracefully handle AudioContext suspension (page backgrounded)\n    - Validate all config inputs\n    - Dispose properly to prevent memory leaks\n\n    Leverage:\n    - Import timing utilities from frontend/src/utils/metronome/timingCalculations.ts\n    - Import types from frontend/src/types/metronome.ts\n\n    Success: Engine maintains sub-5ms timing accuracy, beat events fire precisely, patterns loop correctly, BPM changes apply smoothly, proper resource cleanup on dispose\n    ```\n\n- [ ] 2.3. Create PatternManager service\n  - File: `frontend/src/services/metronome/PatternManager.ts`\n  - Implement pattern validation, beat sequence calculation, intensity mapping\n  - Purpose: Process and validate beat patterns\n  - _Leverage: `frontend/src/utils/metronome/timingCalculations.ts`\n  - _Requirements: REQ-3 (Pattern Customization)\n  - _Prompt:\n    ```\n    Role: Software Engineer with expertise in sequence processing and validation\n\n    Task: Create PatternManager class in frontend/src/services/metronome/PatternManager.ts for pattern validation and processing.\n\n    Implement these methods:\n\n    ```typescript\n    export class PatternManager {\n      validatePattern(pattern: BeatPattern): ValidationResult {\n        // Validate pattern structure\n        // Check length is 2-32\n        // Check all beats are valid intensities\n        // Check accentBeat is within bounds\n        // Return { valid: boolean, errors: string[] }\n      }\n\n      calculateNextBeat(currentBeat: number, pattern: BeatPattern): BeatInfo {\n        // Calculate next beat information in sequence\n        // Wrap around at pattern.length\n        // Apply accent if currentBeat === pattern.accentBeat\n        // Return beat info with intensity from pattern\n      }\n\n      getIntensityVolume(intensity: BeatIntensity, volumeMap: AudioConfig['volumeMap']): number {\n        // Map intensity to volume using volumeMap\n        // 'silent' -> 0\n        // 'light' -> volumeMap.light (default 0.25)\n        // 'medium' -> volumeMap.medium (default 0.5)\n        // 'strong' -> volumeMap.strong (default 1.0)\n      }\n\n      applyAccent(intensity: BeatIntensity, isAccent: boolean): BeatIntensity {\n        // Boost intensity if isAccent is true\n        // 'light' -> 'medium', 'medium' -> 'strong', 'strong' -> 'strong'\n        // 'silent' remains 'silent'\n      }\n    }\n\n    interface ValidationResult {\n      valid: boolean;\n      errors: string[];\n    }\n    ```\n\n    Restrictions:\n    - All methods must be synchronous\n    - Provide clear error messages in validation\n    - Handle edge cases (empty pattern, null values)\n    - No side effects (pure logic)\n\n    Leverage:\n    - Import types from frontend/src/types/metronome.ts\n    - Use timing utilities if needed\n\n    Success: Pattern validation catches all invalid cases, beat calculation handles wrapping correctly, intensity mapping is accurate, accent boost works properly\n    ```\n\n## Phase 3: Audio System\n\n- [ ] 3.1. Create audio file loader utility\n  - File: `frontend/src/utils/metronome/audioLoader.ts`\n  - Implement functions to load built-in and custom audio files into AudioBuffer\n  - Purpose: Handle audio file loading and validation\n  - _Leverage: Web Audio API\n  - _Requirements: REQ-6 (Audio Customization)\n  - _Prompt:\n    ```\n    Role: Frontend Developer with expertise in Web Audio API and file handling\n\n    Task: Create audio loading utilities in frontend/src/utils/metronome/audioLoader.ts.\n\n    Implement these functions:\n\n    ```typescript\n    export async function loadAudioBuffer(\n      audioContext: AudioContext,\n      url: string\n    ): Promise<AudioBuffer> {\n      // Fetch audio file from URL\n      // Convert to ArrayBuffer\n      // Decode using audioContext.decodeAudioData()\n      // Return AudioBuffer\n      // Throw error if loading fails\n    }\n\n    export async function loadCustomAudioFile(\n      audioContext: AudioContext,\n      file: File\n    ): Promise<{ buffer: AudioBuffer; dataUrl: string }> {\n      // Validate file type (audio/wav, audio/mp3, audio/ogg)\n      // Validate file size (<5MB)\n      // Read file as ArrayBuffer\n      // Decode to AudioBuffer\n      // Create data URL for storage\n      // Return both buffer and data URL\n    }\n\n    export function validateAudioFile(file: File): ValidationResult {\n      // Check file type is audio/wav, audio/mp3, or audio/ogg\n      // Check file size is under 5MB\n      // Return validation result with errors\n    }\n\n    export function getBuiltInSoundUrl(soundType: SoundType): string {\n      // Map sound type to asset URL\n      // Return path to built-in sound file\n      // Sound files should be in public/sounds/ directory\n    }\n\n    interface ValidationResult {\n      valid: boolean;\n      errors: string[];\n    }\n    ```\n\n    Built-in sound files (create these as simple sine/square wave samples):\n    - public/sounds/click.wav\n    - public/sounds/beep.wav\n    - public/sounds/drum.wav\n    - public/sounds/snap.wav\n    - public/sounds/woodblock.wav\n\n    Restrictions:\n    - Handle all error cases gracefully\n    - Provide user-friendly error messages\n    - Validate before processing\n    - Clean up resources on errors\n\n    Leverage: Web Audio API decodeAudioData, FileReader API\n\n    Success: Audio files load correctly, custom files validated properly, errors handled gracefully, data URLs generated for persistence\n    ```\n\n- [ ] 3.2. Create AudioScheduler class\n  - File: `frontend/src/services/metronome/AudioScheduler.ts`\n  - Implement audio playback using Web Audio API with volume control per beat\n  - Purpose: Play metronome sounds with precise timing\n  - _Leverage: `frontend/src/utils/metronome/audioLoader.ts`\n  - _Requirements: REQ-6 (Audio Customization)\n  - _Prompt:\n    ```\n    Role: Audio Engineer with expertise in Web Audio API and real-time audio playback\n\n    Task: Create AudioScheduler class in frontend/src/services/metronome/AudioScheduler.ts for precise audio playback.\n\n    Class structure:\n\n    ```typescript\n    export class AudioScheduler {\n      private audioContext: AudioContext;\n      private audioBuffers: Map<SoundType, AudioBuffer> = new Map();\n      private masterGain: GainNode;\n      private currentSoundType: SoundType = 'click';\n\n      constructor(audioContext: AudioContext) {\n        // Store audio context\n        // Create master gain node\n        // Connect gain to destination\n      }\n\n      async loadSound(soundType: SoundType): Promise<void> {\n        // Load built-in sound using audioLoader\n        // Store in audioBuffers map\n        // Set as currentSoundType\n      }\n\n      async loadCustomSound(file: File): Promise<string> {\n        // Validate file using audioLoader\n        // Load file to buffer using audioLoader\n        // Store in audioBuffers with 'custom' key\n        // Return data URL for persistence\n      }\n\n      playBeat(intensity: number, volume: number, time: number): void {\n        // Create AudioBufferSourceNode\n        // Load buffer for currentSoundType\n        // Create gain node for this beat\n        // Set gain to (intensity * volume * masterGain)\n        // Connect: source -> gain -> masterGain -> destination\n        // Schedule start(time) on source node\n        // Auto-disconnect when finished\n      }\n\n      setMasterVolume(volume: number): void {\n        // Update masterGain.gain.value\n        // Clamp to 0-1 range\n      }\n\n      getMasterVolume(): number {\n        // Return masterGain.gain.value\n      }\n\n      setSoundType(soundType: SoundType): void {\n        // Update currentSoundType\n        // Load sound if not already loaded\n      }\n\n      dispose(): void {\n        // Clear all buffers\n        // Disconnect gain node\n      }\n    }\n    ```\n\n    Key implementation details:\n    1. Use AudioBufferSourceNode for each beat (create new node each time)\n    2. Schedule playback using source.start(time) with AudioContext.currentTime\n    3. Apply volume as: beatVolume = intensity * volume * masterVolume\n    4. Use gain nodes for volume control (smoother than buffer manipulation)\n    5. Pre-load all built-in sounds on initialization for zero-latency playback\n\n    Restrictions:\n    - Must not block on audio loading (use async/await)\n    - Handle missing audio buffers gracefully\n    - Dispose of source nodes after playback\n    - Validate all volume inputs (0-1 range)\n\n    Leverage:\n    - Import audioLoader functions from frontend/src/utils/metronome/audioLoader.ts\n    - Import types from frontend/src/types/metronome.ts\n\n    Success: Sounds play with precise timing, volume control works correctly, custom sounds load successfully, no audio artifacts or clicks, proper resource cleanup\n    ```\n\n## Phase 4: Visual Effects System\n\n- [ ] 4.1. Create FlashEffect component\n  - File: `frontend/src/components/visualEffects/FlashEffect.tsx`\n  - Implement full-screen flash effect with configurable color and opacity\n  - Purpose: Render flash visual beat indicator\n  - _Leverage: CSS animations, React\n  - _Requirements: REQ-2 (Visual Beat Overlay), REQ-5 (Visual Customization)\n  - _Prompt:\n    ```\n    Role: Frontend Developer specializing in React and CSS animations\n\n    Task: Create FlashEffect component in frontend/src/components/visualEffects/FlashEffect.tsx.\n\n    Component implementation:\n\n    ```typescript\n    import React, { useEffect, useState } from 'react';\n    import './FlashEffect.css';\n\n    interface FlashEffectProps {\n      intensity: number; // 0-1\n      duration: number; // milliseconds\n      config: {\n        color: string; // hex color\n        opacity: number; // 0-1 (base opacity)\n      };\n      onComplete?: () => void;\n    }\n\n    export function FlashEffect({ intensity, duration, config, onComplete }: FlashEffectProps) {\n      // State: active (boolean) - controls animation\n      // Effect: Set active=true immediately, then false after duration\n      // Effect: Call onComplete after animation finishes\n\n      // Calculate final opacity: config.opacity * intensity\n      // Apply color and opacity as inline styles or CSS variables\n\n      // Render full-screen overlay div\n      // Use CSS transition for fade out\n      // Apply pointer-events: none (don't block video controls)\n\n      return (\n        <div\n          className={`flash-effect ${active ? 'flash-effect--active' : ''}`}\n          style={{\n            '--flash-color': config.color,\n            '--flash-opacity': finalOpacity,\n            '--flash-duration': `${duration}ms`,\n          } as React.CSSProperties}\n        />\n      );\n    }\n    ```\n\n    CSS (FlashEffect.css):\n    ```css\n    .flash-effect {\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      background-color: var(--flash-color);\n      opacity: 0;\n      pointer-events: none;\n      z-index: 9999;\n      transition: opacity var(--flash-duration) ease-out;\n    }\n\n    .flash-effect--active {\n      opacity: var(--flash-opacity);\n      transition: none; /* Instant on, fade out */\n    }\n    ```\n\n    Restrictions:\n    - Must not block video controls (pointer-events: none)\n    - Use GPU-accelerated properties (opacity, transform)\n    - Clean animation (no flicker)\n    - Handle rapid beats without overlap (component remounts)\n\n    Leverage: React hooks (useState, useEffect), CSS custom properties\n\n    Success: Flash appears instantly at full opacity, fades out smoothly over duration, doesn't block interactions, intensity affects brightness correctly\n    ```\n\n- [ ] 4.2. Create PulseEffect component\n  - File: `frontend/src/components/visualEffects/PulseEffect.tsx`\n  - Implement expanding/contracting shape effect with configurable position and shape\n  - Purpose: Render pulse visual beat indicator\n  - _Leverage: CSS animations, React\n  - _Requirements: REQ-2 (Visual Beat Overlay), REQ-5 (Visual Customization)\n  - _Prompt:\n    ```\n    Role: Frontend Developer specializing in React and CSS animations\n\n    Task: Create PulseEffect component in frontend/src/components/visualEffects/PulseEffect.tsx.\n\n    Component implementation:\n\n    ```typescript\n    import React, { useEffect, useState } from 'react';\n    import './PulseEffect.css';\n\n    interface PulseEffectProps {\n      intensity: number; // 0-1\n      duration: number; // milliseconds\n      config: {\n        color: string;\n        opacity: number;\n        size: number; // percentage of screen (10-100)\n        position: { x: number; y: number }; // percentage (0-100)\n        shape: 'circle' | 'square' | 'diamond' | 'star';\n      };\n      onComplete?: () => void;\n    }\n\n    export function PulseEffect({ intensity, duration, config, onComplete }: PulseEffectProps) {\n      // State: active (boolean)\n      // Effect: Trigger animation, call onComplete after duration\n\n      // Calculate final size: config.size * (1 + intensity * 0.5)\n      // Start at small size, expand to finalSize, fade opacity to 0\n\n      // Position using absolute positioning with config.position\n\n      // Render shape based on config.shape\n      // - circle: border-radius: 50%\n      // - square: border-radius: 0\n      // - diamond: transform: rotate(45deg)\n      // - star: use SVG or clip-path\n\n      return (\n        <div\n          className={`pulse-effect pulse-effect--${config.shape} ${active ? 'pulse-effect--active' : ''}`}\n          style={{\n            '--pulse-color': config.color,\n            '--pulse-opacity': config.opacity * intensity,\n            '--pulse-size': `${finalSize}vh`,\n            '--pulse-duration': `${duration}ms`,\n            left: `${config.position.x}%`,\n            top: `${config.position.y}%`,\n          } as React.CSSProperties}\n        />\n      );\n    }\n    ```\n\n    CSS (PulseEffect.css):\n    ```css\n    .pulse-effect {\n      position: fixed;\n      width: 10vh;\n      height: 10vh;\n      background-color: var(--pulse-color);\n      opacity: var(--pulse-opacity);\n      pointer-events: none;\n      z-index: 9999;\n      transform: translate(-50%, -50%) scale(0.1);\n      transition: transform var(--pulse-duration) ease-out,\n                  opacity var(--pulse-duration) ease-out;\n    }\n\n    .pulse-effect--active {\n      transform: translate(-50%, -50%) scale(1);\n      opacity: 0;\n    }\n\n    .pulse-effect--circle {\n      border-radius: 50%;\n    }\n\n    .pulse-effect--square {\n      border-radius: 0;\n    }\n\n    .pulse-effect--diamond {\n      transform: translate(-50%, -50%) rotate(45deg) scale(0.1);\n    }\n\n    .pulse-effect--diamond.pulse-effect--active {\n      transform: translate(-50%, -50%) rotate(45deg) scale(1);\n    }\n    ```\n\n    Restrictions:\n    - Must not block video controls\n    - Use transform for animations (GPU accelerated)\n    - Handle shape rendering efficiently\n    - Position accurately using percentages\n\n    Success: Pulse expands smoothly from center, fades out correctly, shape renders properly, position is accurate, intensity affects size\n    ```\n\n- [ ] 4.3. Create BorderEffect component\n  - File: `frontend/src/components/visualEffects/BorderEffect.tsx`\n  - Implement border highlight around video with configurable thickness and color\n  - Purpose: Render border visual beat indicator\n  - _Leverage: CSS animations, React\n  - _Requirements: REQ-2 (Visual Beat Overlay), REQ-5 (Visual Customization)\n  - _Prompt:\n    ```\n    Role: Frontend Developer specializing in React and CSS animations\n\n    Task: Create BorderEffect component in frontend/src/components/visualEffects/BorderEffect.tsx.\n\n    Component implementation:\n\n    ```typescript\n    import React, { useEffect, useState } from 'react';\n    import './BorderEffect.css';\n\n    interface BorderEffectProps {\n      intensity: number; // 0-1\n      duration: number; // milliseconds\n      config: {\n        color: string;\n        opacity: number;\n        thickness: number; // pixels (5-50)\n      };\n      onComplete?: () => void;\n    }\n\n    export function BorderEffect({ intensity, duration, config, onComplete }: BorderEffectProps) {\n      // State: active (boolean)\n      // Effect: Trigger animation, call onComplete\n\n      // Calculate final thickness: config.thickness * (1 + intensity)\n      // Animate opacity from full to 0\n      // Animate thickness from finalThickness to 0\n\n      return (\n        <div\n          className={`border-effect ${active ? 'border-effect--active' : ''}`}\n          style={{\n            '--border-color': config.color,\n            '--border-opacity': config.opacity * intensity,\n            '--border-thickness': `${finalThickness}px`,\n            '--border-duration': `${duration}ms`,\n          } as React.CSSProperties}\n        />\n      );\n    }\n    ```\n\n    CSS (BorderEffect.css):\n    ```css\n    .border-effect {\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      border: var(--border-thickness) solid var(--border-color);\n      opacity: var(--border-opacity);\n      pointer-events: none;\n      z-index: 9999;\n      box-sizing: border-box;\n      transition: opacity var(--border-duration) ease-out,\n                  border-width var(--border-duration) ease-out;\n    }\n\n    .border-effect--active {\n      opacity: 0;\n      border-width: 0;\n    }\n    ```\n\n    Restrictions:\n    - Must not block video controls\n    - Border must not cause layout shifts\n    - Use box-sizing: border-box\n    - Smooth animation\n\n    Success: Border appears at full thickness, shrinks and fades smoothly, doesn't affect layout, intensity affects thickness correctly\n    ```\n\n- [ ] 4.4. Create VisualEffectRenderer component\n  - File: `frontend/src/components/MetronomeVisualEffects.tsx`\n  - Implement factory component that renders appropriate visual effect based on config\n  - Purpose: Render the correct visual effect component\n  - _Leverage: FlashEffect, PulseEffect, BorderEffect components\n  - _Requirements: REQ-2 (Visual Beat Overlay)\n  - _Prompt:\n    ```\n    Role: React Developer with expertise in component composition\n\n    Task: Create VisualEffectRenderer component in frontend/src/components/MetronomeVisualEffects.tsx that selects and renders the appropriate visual effect.\n\n    Component implementation:\n\n    ```typescript\n    import React from 'react';\n    import { FlashEffect } from './visualEffects/FlashEffect';\n    import { PulseEffect } from './visualEffects/PulseEffect';\n    import { BorderEffect } from './visualEffects/BorderEffect';\n    import type { BeatEffect, VisualConfig } from '../types/metronome';\n\n    interface VisualEffectRendererProps {\n      effect: BeatEffect | null;\n      config: VisualConfig;\n    }\n\n    export function VisualEffectRenderer({ effect, config }: VisualEffectRendererProps) {\n      // Return null if effect is null or visual not enabled\n      if (!effect || !config.enabled) {\n        return null;\n      }\n\n      // Use discriminated union to select component\n      switch (config.visualStyle) {\n        case 'flash':\n          return (\n            <FlashEffect\n              intensity={effect.intensity}\n              duration={effect.duration}\n              config={{ color: config.color, opacity: config.opacity }}\n            />\n          );\n\n        case 'pulse':\n          return (\n            <PulseEffect\n              intensity={effect.intensity}\n              duration={effect.duration}\n              config={{\n                color: config.color,\n                opacity: config.opacity,\n                size: config.size,\n                position: config.position,\n                shape: config.shape,\n              }}\n            />\n          );\n\n        case 'border':\n          return (\n            <BorderEffect\n              intensity={effect.intensity}\n              duration={effect.duration}\n              config={{\n                color: config.color,\n                opacity: config.opacity,\n                thickness: config.thickness,\n              }}\n            />\n          );\n\n        case 'none':\n          return null;\n\n        default:\n          // TypeScript exhaustiveness check\n          const _exhaustive: never = config;\n          return null;\n      }\n    }\n    ```\n\n    Restrictions:\n    - Must use discriminated union for type safety\n    - Handle all visual style cases\n    - Return null for disabled or none styles\n    - Use exhaustiveness checking\n\n    Success: Correct effect renders for each style, TypeScript prevents missing cases, null handling works properly\n    ```\n\n## Phase 5: React Hooks\n\n- [ ] 5.1. Create useMetronome hook\n  - File: `frontend/src/hooks/useMetronome.ts`\n  - Implement main hook orchestrating metronome state and video player synchronization\n  - Purpose: Connect metronome engine to React lifecycle and video player\n  - _Leverage: MetronomeEngine, useVideoPlayer hook\n  - _Requirements: REQ-1 (Basic Metronome), REQ-7 (Playlist Integration), REQ-9 (Controls)\n  - _Prompt:\n    ```\n    Role: Senior React Developer with expertise in custom hooks and complex state management\n\n    Task: Create useMetronome hook in frontend/src/hooks/useMetronome.ts. This is the main orchestration hook that connects everything.\n\n    Hook implementation:\n\n    ```typescript\n    import { useState, useEffect, useRef, useCallback } from 'react';\n    import { MetronomeEngine } from '../services/metronome/MetronomeEngine';\n    import type { UseVideoPlayerReturn } from './useVideoPlayer';\n    import type { MetronomeConfig } from '../types/metronome';\n\n    export interface UseMetronomeReturn {\n      // State\n      enabled: boolean;\n      config: MetronomeConfig;\n      currentBeat: number;\n      isRunning: boolean;\n\n      // Controls\n      toggle: () => void;\n      start: () => void;\n      stop: () => void;\n      updateConfig: (partial: Partial<MetronomeConfig>) => void;\n\n      // Engine reference for other hooks\n      engineRef: React.MutableRefObject<MetronomeEngine | null>;\n    }\n\n    const DEFAULT_CONFIG: MetronomeConfig = {\n      bpm: 60,\n      enabled: false,\n      pattern: { beats: ['strong', 'medium', 'medium', 'light'], length: 4, accentBeat: null },\n      patternEnabled: false,\n      randomization: 0,\n      randomizationEnabled: false,\n      tempoChange: { mode: 'accelerate', changePerMinute: 0, minBPM: 30, maxBPM: 300, resetOnStop: true },\n      tempoChangeEnabled: false,\n      audio: {\n        soundType: 'click',\n        customSoundUrl: null,\n        masterVolume: 0.7,\n        muted: false,\n        volumeVariation: true,\n        volumeMap: { silent: 0, light: 0.25, medium: 0.5, strong: 1.0 },\n      },\n      visual: {\n        enabled: true,\n        visualStyle: 'flash',\n        color: '#ffffff',\n        opacity: 0.3,\n        size: 50,\n        position: { x: 50, y: 50, preset: 'center' },\n        shape: 'circle',\n        multiOverlay: false,\n      },\n      syncToVideo: true,\n      continuousMode: false,\n    };\n\n    export function useMetronome(playerState: UseVideoPlayerReturn): UseMetronomeReturn {\n      const [config, setConfig] = useState<MetronomeConfig>(DEFAULT_CONFIG);\n      const [enabled, setEnabled] = useState(false);\n      const [currentBeat, setCurrentBeat] = useState(0);\n      const [isRunning, setIsRunning] = useState(false);\n\n      const engineRef = useRef<MetronomeEngine | null>(null);\n\n      // Initialize engine on mount\n      useEffect(() => {\n        engineRef.current = new MetronomeEngine();\n\n        return () => {\n          engineRef.current?.dispose();\n          engineRef.current = null;\n        };\n      }, []);\n\n      // Sync with video player play/pause\n      useEffect(() => {\n        if (!config.syncToVideo || !engineRef.current) return;\n\n        const engine = engineRef.current;\n\n        if (playerState.playing && enabled && !isRunning) {\n          engine.resume();\n          setIsRunning(true);\n        } else if (!playerState.playing && isRunning) {\n          engine.pause();\n          setIsRunning(false);\n        }\n      }, [playerState.playing, config.syncToVideo, enabled, isRunning]);\n\n      // Sync with video seek\n      useEffect(() => {\n        if (!config.syncToVideo || !engineRef.current) return;\n\n        // Calculate which beat should be playing at current video time\n        const beatNumber = Math.floor((playerState.currentTime * config.bpm) / 60);\n        engineRef.current.seekToBeat(beatNumber % config.pattern.length);\n      }, [playerState.currentTime, config.syncToVideo, config.bpm, config.pattern.length]);\n\n      // Subscribe to beat events\n      useEffect(() => {\n        if (!engineRef.current) return;\n\n        const handleBeat = (beatInfo: BeatInfo) => {\n          setCurrentBeat(beatInfo.beatNumber);\n        };\n\n        engineRef.current.on('beat', handleBeat);\n\n        return () => {\n          engineRef.current?.off('beat', handleBeat);\n        };\n      }, []);\n\n      const toggle = useCallback(() => {\n        setEnabled((prev) => !prev);\n      }, []);\n\n      const start = useCallback(() => {\n        if (!engineRef.current) return;\n        engineRef.current.start(config);\n        setEnabled(true);\n        setIsRunning(true);\n      }, [config]);\n\n      const stop = useCallback(() => {\n        if (!engineRef.current) return;\n        engineRef.current.stop();\n        setEnabled(false);\n        setIsRunning(false);\n      }, []);\n\n      const updateConfig = useCallback((partial: Partial<MetronomeConfig>) => {\n        setConfig((prev) => ({ ...prev, ...partial }));\n\n        // Apply real-time updates to engine\n        if (engineRef.current && isRunning) {\n          if (partial.bpm !== undefined) {\n            engineRef.current.updateBPM(partial.bpm);\n          }\n          if (partial.pattern !== undefined) {\n            engineRef.current.updatePattern(partial.pattern);\n          }\n        }\n      }, [isRunning]);\n\n      return {\n        enabled,\n        config,\n        currentBeat,\n        isRunning,\n        toggle,\n        start,\n        stop,\n        updateConfig,\n        engineRef,\n      };\n    }\n    ```\n\n    Restrictions:\n    - Must properly clean up engine on unmount\n    - Handle video player state changes correctly\n    - Apply config updates in real-time when running\n    - Maintain stable references with useCallback\n\n    Leverage:\n    - Import MetronomeEngine from frontend/src/services/metronome/MetronomeEngine.ts\n    - Import types from frontend/src/types/metronome.ts\n    - Receive useVideoPlayer state as parameter\n\n    Success: Metronome syncs with video play/pause/seek, config updates apply in real-time, proper cleanup prevents memory leaks, stable hook API\n    ```\n\n- [ ] 5.2. Create useMetronomeAudio hook\n  - File: `frontend/src/hooks/useMetronomeAudio.ts`\n  - Implement hook managing audio playback and connecting AudioScheduler to beat events\n  - Purpose: Handle audio layer of metronome\n  - _Leverage: AudioScheduler, MetronomeEngine\n  - _Requirements: REQ-6 (Audio Customization)\n  - _Prompt:\n    ```\n    Role: React Developer with expertise in Web Audio API and React hooks\n\n    Task: Create useMetronomeAudio hook in frontend/src/hooks/useMetronomeAudio.ts to manage audio playback.\n\n    Hook implementation:\n\n    ```typescript\n    import { useEffect, useRef, useState } from 'react';\n    import { AudioScheduler } from '../services/metronome/AudioScheduler';\n    import { PatternManager } from '../services/metronome/PatternManager';\n    import type { MetronomeEngine } from '../services/metronome/MetronomeEngine';\n    import type { AudioConfig } from '../types/metronome';\n\n    export interface UseMetronomeAudioReturn {\n      audioScheduler: React.MutableRefObject<AudioScheduler | null>;\n      loadingSound: boolean;\n      audioError: string | null;\n      setVolume: (volume: number) => void;\n      setSoundType: (type: SoundType) => void;\n      loadCustomSound: (file: File) => Promise<void>;\n    }\n\n    export function useMetronomeAudio(\n      engineRef: React.MutableRefObject<MetronomeEngine | null>,\n      audioConfig: AudioConfig\n    ): UseMetronomeAudioReturn {\n      const audioSchedulerRef = useRef<AudioScheduler | null>(null);\n      const audioContextRef = useRef<AudioContext | null>(null);\n      const patternManagerRef = useRef<PatternManager>(new PatternManager());\n\n      const [loadingSound, setLoadingSound] = useState(false);\n      const [audioError, setAudioError] = useState<string | null>(null);\n\n      // Initialize AudioContext and AudioScheduler\n      useEffect(() => {\n        try {\n          const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;\n          audioContextRef.current = new AudioContextClass();\n          audioSchedulerRef.current = new AudioScheduler(audioContextRef.current);\n\n          // Load default sound\n          audioSchedulerRef.current.loadSound(audioConfig.soundType).catch((err) => {\n            setAudioError(`Failed to load sound: ${err.message}`);\n          });\n        } catch (err) {\n          setAudioError('Web Audio API not supported');\n        }\n\n        return () => {\n          audioSchedulerRef.current?.dispose();\n          audioContextRef.current?.close();\n        };\n      }, []);\n\n      // Subscribe to beat events and play sounds\n      useEffect(() => {\n        if (!engineRef.current || !audioSchedulerRef.current) return;\n\n        const handleBeat = (beatInfo: BeatInfo) => {\n          if (audioConfig.muted) return;\n\n          // Get volume for this intensity\n          const volume = patternManagerRef.current.getIntensityVolume(\n            beatInfo.intensity,\n            audioConfig.volumeMap\n          );\n\n          // Play sound at correct time\n          audioSchedulerRef.current!.playBeat(\n            beatInfo.intensity === 'silent' ? 0 : 1,\n            volume * audioConfig.masterVolume,\n            beatInfo.timestamp\n          );\n        };\n\n        engineRef.current.on('beat', handleBeat);\n\n        return () => {\n          engineRef.current?.off('beat', handleBeat);\n        };\n      }, [engineRef, audioConfig.muted, audioConfig.volumeMap, audioConfig.masterVolume]);\n\n      // Update master volume when config changes\n      useEffect(() => {\n        if (audioSchedulerRef.current) {\n          audioSchedulerRef.current.setMasterVolume(audioConfig.masterVolume);\n        }\n      }, [audioConfig.masterVolume]);\n\n      // Change sound type when config changes\n      useEffect(() => {\n        if (audioSchedulerRef.current) {\n          setLoadingSound(true);\n          audioSchedulerRef.current\n            .loadSound(audioConfig.soundType)\n            .then(() => {\n              setLoadingSound(false);\n              setAudioError(null);\n            })\n            .catch((err) => {\n              setLoadingSound(false);\n              setAudioError(`Failed to load sound: ${err.message}`);\n            });\n        }\n      }, [audioConfig.soundType]);\n\n      const setVolume = (volume: number) => {\n        if (audioSchedulerRef.current) {\n          audioSchedulerRef.current.setMasterVolume(volume);\n        }\n      };\n\n      const setSoundType = (type: SoundType) => {\n        if (audioSchedulerRef.current) {\n          audioSchedulerRef.current.setSoundType(type);\n        }\n      };\n\n      const loadCustomSound = async (file: File): Promise<void> => {\n        if (!audioSchedulerRef.current) {\n          throw new Error('Audio scheduler not initialized');\n        }\n\n        setLoadingSound(true);\n        try {\n          await audioSchedulerRef.current.loadCustomSound(file);\n          setLoadingSound(false);\n          setAudioError(null);\n        } catch (err: any) {\n          setLoadingSound(false);\n          setAudioError(err.message);\n          throw err;\n        }\n      };\n\n      return {\n        audioScheduler: audioSchedulerRef,\n        loadingSound,\n        audioError,\n        setVolume,\n        setSoundType,\n        loadCustomSound,\n      };\n    }\n    ```\n\n    Restrictions:\n    - Must handle Web Audio API unavailability gracefully\n    - Properly clean up AudioContext on unmount\n    - Handle audio loading errors with user-friendly messages\n    - Respect muted state\n\n    Success: Sounds play in sync with beats, volume control works, sound loading is handled properly, errors are user-friendly, proper cleanup\n    ```\n\n- [ ] 5.3. Create useMetronomeVisuals hook\n  - File: `frontend/src/hooks/useMetronomeVisuals.ts`\n  - Implement hook managing visual effect state and triggering renders on beats\n  - Purpose: Handle visual layer of metronome\n  - _Leverage: MetronomeEngine\n  - _Requirements: REQ-2 (Visual Beat Overlay), REQ-5 (Visual Customization)\n  - _Prompt:\n    ```\n    Role: React Developer with expertise in animation and visual effects\n\n    Task: Create useMetronomeVisuals hook in frontend/src/hooks/useMetronomeVisuals.ts to manage visual effects.\n\n    Hook implementation:\n\n    ```typescript\n    import { useState, useEffect, useCallback } from 'react';\n    import type { MetronomeEngine } from '../services/metronome/MetronomeEngine';\n    import type { VisualConfig, BeatEffect } from '../types/metronome';\n\n    export interface UseMetronomeVisualsReturn {\n      activeEffect: BeatEffect | null;\n      updateVisualConfig: (config: Partial<VisualConfig>) => void;\n    }\n\n    export function useMetronomeVisuals(\n      engineRef: React.MutableRefObject<MetronomeEngine | null>,\n      visualConfig: VisualConfig\n    ): UseMetronomeVisualsReturn {\n      const [activeEffect, setActiveEffect] = useState<BeatEffect | null>(null);\n\n      // Subscribe to beat events\n      useEffect(() => {\n        if (!engineRef.current || !visualConfig.enabled) return;\n\n        const handleBeat = (beatInfo: BeatInfo) => {\n          // Calculate effect duration (default to 80% of beat duration)\n          const bpm = 60; // This should come from config in real implementation\n          const beatDurationMs = (60 / bpm) * 1000;\n          const effectDuration = beatDurationMs * 0.8;\n\n          // Set active effect (triggers render)\n          setActiveEffect({\n            intensity: beatInfo.volume, // Use volume as intensity proxy\n            timestamp: beatInfo.timestamp,\n            duration: effectDuration,\n          });\n\n          // Clear effect after duration to prevent overlap\n          setTimeout(() => {\n            setActiveEffect(null);\n          }, effectDuration);\n        };\n\n        engineRef.current.on('beat', handleBeat);\n\n        return () => {\n          engineRef.current?.off('beat', handleBeat);\n        };\n      }, [engineRef, visualConfig.enabled]);\n\n      const updateVisualConfig = useCallback((config: Partial<VisualConfig>) => {\n        // This would update parent component config\n        // Implementation depends on how config is managed\n      }, []);\n\n      return {\n        activeEffect,\n        updateVisualConfig,\n      };\n    }\n    ```\n\n    Restrictions:\n    - Must clear effects to prevent overlap\n    - Calculate appropriate effect duration\n    - Handle disabled state\n    - Efficient state updates\n\n    Success: Visual effects trigger on beats, effects clear properly, no overlap issues, respects enabled state\n    ```\n\n- [ ] 5.4. Create useMetronomePresets hook\n  - File: `frontend/src/hooks/useMetronomePresets.ts`\n  - Implement hook managing preset CRUD with localStorage persistence\n  - Purpose: Handle preset management\n  - _Leverage: localStorage API\n  - _Requirements: REQ-8 (Preset Management)\n  - _Prompt:\n    ```\n    Role: React Developer with expertise in data persistence and state management\n\n    Task: Create useMetronomePresets hook in frontend/src/hooks/useMetronomePresets.ts for preset management.\n\n    Hook implementation:\n\n    ```typescript\n    import { useState, useEffect, useCallback } from 'react';\n    import type { MetronomeConfig, MetronomePreset } from '../types/metronome';\n\n    const STORAGE_KEY = 'metronome_presets';\n    const MAX_PRESETS = 50;\n\n    export interface UseMetronomePresetsReturn {\n      presets: MetronomePreset[];\n      savePreset: (name: string, config: MetronomeConfig, description?: string) => void;\n      loadPreset: (id: string) => MetronomeConfig | null;\n      deletePreset: (id: string) => void;\n      exportPresets: () => string;\n      importPresets: (json: string) => { success: boolean; error?: string };\n      error: string | null;\n    }\n\n    function generateId(): string {\n      return `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    export function useMetronomePresets(): UseMetronomePresetsReturn {\n      const [presets, setPresets] = useState<MetronomePreset[]>([]);\n      const [error, setError] = useState<string | null>(null);\n\n      // Load presets from localStorage on mount\n      useEffect(() => {\n        try {\n          const stored = localStorage.getItem(STORAGE_KEY);\n          if (stored) {\n            const parsed = JSON.parse(stored);\n            setPresets(Array.isArray(parsed) ? parsed : []);\n          }\n        } catch (err) {\n          setError('Failed to load presets from storage');\n        }\n      }, []);\n\n      // Save presets to localStorage whenever they change\n      useEffect(() => {\n        try {\n          localStorage.setItem(STORAGE_KEY, JSON.stringify(presets));\n        } catch (err: any) {\n          if (err.name === 'QuotaExceededError') {\n            setError('Storage quota exceeded. Delete unused presets.');\n          } else {\n            setError('Failed to save presets');\n          }\n        }\n      }, [presets]);\n\n      const savePreset = useCallback((name: string, config: MetronomeConfig, description?: string) => {\n        if (presets.length >= MAX_PRESETS) {\n          setError(`Maximum ${MAX_PRESETS} presets allowed`);\n          return;\n        }\n\n        const now = new Date().toISOString();\n        const newPreset: MetronomePreset = {\n          id: generateId(),\n          name,\n          description: description || null,\n          config,\n          createdAt: now,\n          updatedAt: now,\n        };\n\n        setPresets((prev) => [...prev, newPreset]);\n        setError(null);\n      }, [presets.length]);\n\n      const loadPreset = useCallback((id: string): MetronomeConfig | null => {\n        const preset = presets.find((p) => p.id === id);\n        return preset ? preset.config : null;\n      }, [presets]);\n\n      const deletePreset = useCallback((id: string) => {\n        setPresets((prev) => prev.filter((p) => p.id !== id));\n        setError(null);\n      }, []);\n\n      const exportPresets = useCallback((): string => {\n        return JSON.stringify(presets, null, 2);\n      }, [presets]);\n\n      const importPresets = useCallback((json: string): { success: boolean; error?: string } => {\n        try {\n          const parsed = JSON.parse(json);\n\n          if (!Array.isArray(parsed)) {\n            return { success: false, error: 'Invalid format: expected array' };\n          }\n\n          // Validate structure\n          const valid = parsed.every((p) =>\n            p.id && p.name && p.config && p.createdAt && p.updatedAt\n          );\n\n          if (!valid) {\n            return { success: false, error: 'Invalid preset structure' };\n          }\n\n          setPresets(parsed);\n          setError(null);\n          return { success: true };\n        } catch (err) {\n          return { success: false, error: 'Failed to parse JSON' };\n        }\n      }, []);\n\n      return {\n        presets,\n        savePreset,\n        loadPreset,\n        deletePreset,\n        exportPresets,\n        importPresets,\n        error,\n      };\n    }\n    ```\n\n    Restrictions:\n    - Must handle localStorage quota errors\n    - Validate imported JSON structure\n    - Limit number of presets (50 max)\n    - Generate unique IDs\n\n    Success: Presets persist across sessions, CRUD operations work correctly, quota errors handled gracefully, import validation works\n    ```\n\n## Phase 6: UI Components\n\n- [ ] 6.1. Create MetronomeControls component\n  - File: `frontend/src/components/MetronomeControls.tsx`\n  - Implement basic controls (BPM slider, play/pause toggle, settings button)\n  - Purpose: Provide user controls for metronome\n  - _Leverage: React, existing UI patterns\n  - _Requirements: REQ-9 (Controls and UI Integration)\n  - _Prompt:\n    ```\n    Role: UI/UX Developer specializing in React and accessible interfaces\n\n    Task: Create MetronomeControls component in frontend/src/components/MetronomeControls.tsx with basic metronome controls.\n\n    Component implementation:\n\n    ```typescript\n    import React from 'react';\n    import './MetronomeControls.css';\n\n    interface MetronomeControlsProps {\n      enabled: boolean;\n      bpm: number;\n      isRunning: boolean;\n      onToggle: () => void;\n      onBPMChange: (bpm: number) => void;\n      onOpenSettings: () => void;\n    }\n\n    export function MetronomeControls({\n      enabled,\n      bpm,\n      isRunning,\n      onToggle,\n      onBPMChange,\n      onOpenSettings,\n    }: MetronomeControlsProps) {\n      return (\n        <div className=\"metronome-controls\">\n          {/* Toggle Button */}\n          <button\n            className={`metronome-controls__toggle ${enabled ? 'active' : ''}`}\n            onClick={onToggle}\n            aria-label={enabled ? 'Disable metronome' : 'Enable metronome'}\n            data-testid=\"metronome-toggle\"\n          >\n            <svg className=\"metronome-icon\" viewBox=\"0 0 24 24\">\n              {/* Metronome icon SVG */}\n              <path d=\"M12 2 L12 22 M8 10 L12 2 L16 10\" stroke=\"currentColor\" strokeWidth=\"2\" fill=\"none\" />\n            </svg>\n            {isRunning && <span className=\"pulse-indicator\" />}\n          </button>\n\n          {/* BPM Slider (shown when enabled) */}\n          {enabled && (\n            <div className=\"metronome-controls__bpm\">\n              <label htmlFor=\"bpm-slider\" className=\"metronome-controls__bpm-label\">\n                BPM\n              </label>\n              <input\n                id=\"bpm-slider\"\n                type=\"range\"\n                min=\"30\"\n                max=\"300\"\n                step=\"1\"\n                value={bpm}\n                onChange={(e) => onBPMChange(Number(e.target.value))}\n                className=\"metronome-controls__bpm-slider\"\n                aria-label=\"Beats per minute\"\n                aria-valuemin=\"30\"\n                aria-valuemax=\"300\"\n                aria-valuenow={bpm}\n              />\n              <span className=\"metronome-controls__bpm-value\">{bpm}</span>\n            </div>\n          )}\n\n          {/* Settings Button */}\n          {enabled && (\n            <button\n              className=\"metronome-controls__settings\"\n              onClick={onOpenSettings}\n              aria-label=\"Open metronome settings\"\n              data-testid=\"metronome-settings-btn\"\n            >\n              <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                <circle cx=\"12\" cy=\"12\" r=\"3\" />\n                <path d=\"M12 1v6m0 6v6M4.22 4.22l4.24 4.24m7.08 7.08l4.24 4.24M1 12h6m6 0h6M4.22 19.78l4.24-4.24m7.08-7.08l4.24-4.24\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      );\n    }\n    ```\n\n    CSS (MetronomeControls.css):\n    ```css\n    .metronome-controls {\n      display: flex;\n      align-items: center;\n      gap: 12px;\n      padding: 8px 12px;\n      background: rgba(0, 0, 0, 0.7);\n      border-radius: 8px;\n    }\n\n    .metronome-controls__toggle {\n      width: 40px;\n      height: 40px;\n      border: none;\n      background: transparent;\n      color: #fff;\n      cursor: pointer;\n      position: relative;\n      border-radius: 50%;\n      transition: background-color 0.2s;\n    }\n\n    .metronome-controls__toggle:hover {\n      background: rgba(255, 255, 255, 0.1);\n    }\n\n    .metronome-controls__toggle.active {\n      color: #4CAF50;\n    }\n\n    .pulse-indicator {\n      position: absolute;\n      top: 4px;\n      right: 4px;\n      width: 8px;\n      height: 8px;\n      background: #4CAF50;\n      border-radius: 50%;\n      animation: pulse 1s ease-in-out infinite;\n    }\n\n    @keyframes pulse {\n      0%, 100% { opacity: 1; }\n      50% { opacity: 0.3; }\n    }\n\n    .metronome-controls__bpm {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n    }\n\n    .metronome-controls__bpm-slider {\n      width: 150px;\n    }\n\n    .metronome-controls__bpm-value {\n      min-width: 40px;\n      text-align: center;\n      color: #fff;\n      font-weight: bold;\n    }\n\n    .metronome-controls__settings {\n      width: 32px;\n      height: 32px;\n      border: none;\n      background: transparent;\n      color: #fff;\n      cursor: pointer;\n      border-radius: 50%;\n    }\n\n    .metronome-controls__settings:hover {\n      background: rgba(255, 255, 255, 0.1);\n    }\n    ```\n\n    Restrictions:\n    - Must be keyboard accessible\n    - Include ARIA labels\n    - Visual feedback on all interactions\n    - Responsive to container width\n\n    Success: Controls are intuitive and accessible, BPM slider works smoothly, toggle state is clear, settings button opens panel\n    ```\n\n- [ ] 6.2. Create MetronomeSettingsPanel component\n  - File: `frontend/src/components/MetronomeSettingsPanel.tsx`\n  - Implement comprehensive settings panel with sections for all configuration options\n  - Purpose: Provide detailed metronome configuration UI\n  - _Leverage: React, useMetronome hook\n  - _Requirements: REQ-3 to REQ-8 (All customization requirements)\n  - _Prompt:\n    ```\n    Role: Frontend Developer specializing in complex forms and UI components\n\n    Task: Create MetronomeSettingsPanel component in frontend/src/components/MetronomeSettingsPanel.tsx. This is a comprehensive settings panel with multiple sections.\n\n    Due to length, implement this in phases:\n\n    Phase 1 - Component Structure:\n    ```typescript\n    import React, { useState } from 'react';\n    import './MetronomeSettingsPanel.css';\n    import type { MetronomeConfig, MetronomePreset } from '../types/metronome';\n\n    interface MetronomeSettingsPanelProps {\n      config: MetronomeConfig;\n      presets: MetronomePreset[];\n      onConfigChange: (config: Partial<MetronomeConfig>) => void;\n      onLoadPreset: (id: string) => void;\n      onSavePreset: (name: string) => void;\n      onDeletePreset: (id: string) => void;\n      onClose: () => void;\n    }\n\n    type SettingsTab = 'basic' | 'pattern' | 'visual' | 'audio' | 'presets';\n\n    export function MetronomeSettingsPanel(props: MetronomeSettingsPanelProps) {\n      const [activeTab, setActiveTab] = useState<SettingsTab>('basic');\n\n      return (\n        <div className=\"metronome-settings-panel\">\n          <div className=\"metronome-settings-panel__header\">\n            <h3>Metronome Settings</h3>\n            <button onClick={props.onClose} aria-label=\"Close settings\">×</button>\n          </div>\n\n          <div className=\"metronome-settings-panel__tabs\">\n            {/* Tab buttons */}\n            <button\n              className={activeTab === 'basic' ? 'active' : ''}\n              onClick={() => setActiveTab('basic')}\n            >\n              Basic\n            </button>\n            {/* ... other tabs ... */}\n          </div>\n\n          <div className=\"metronome-settings-panel__content\">\n            {activeTab === 'basic' && <BasicSettings {...props} />}\n            {activeTab === 'pattern' && <PatternSettings {...props} />}\n            {activeTab === 'visual' && <VisualSettings {...props} />}\n            {activeTab === 'audio' && <AudioSettings {...props} />}\n            {activeTab === 'presets' && <PresetSettings {...props} />}\n          </div>\n        </div>\n      );\n    }\n\n    // Sub-components for each section\n    function BasicSettings(props: MetronomeSettingsPanelProps) {\n      // BPM slider\n      // Randomization controls\n      // Tempo change controls\n      // Sync options\n    }\n\n    function PatternSettings(props: MetronomeSettingsPanelProps) {\n      // Pattern enable toggle\n      // Pattern length selector\n      // Beat intensity grid (click to cycle through light/medium/strong/silent)\n      // Accent beat selector\n    }\n\n    function VisualSettings(props: MetronomeSettingsPanelProps) {\n      // Visual enable toggle\n      // Style selector (flash/pulse/border/none)\n      // Color picker\n      // Opacity slider\n      // Size/position/shape controls (conditional on style)\n    }\n\n    function AudioSettings(props: MetronomeSettingsPanelProps) {\n      // Sound type selector\n      // Master volume slider\n      // Mute toggle\n      // Volume variation toggle\n      // Custom sound upload\n    }\n\n    function PresetSettings(props: MetronomeSettingsPanelProps) {\n      // Preset list\n      // Load/Delete buttons per preset\n      // Save new preset form\n      // Export/Import buttons\n    }\n    ```\n\n    Implementation notes:\n    - Use controlled components (all inputs controlled by config prop)\n    - Apply changes immediately via onConfigChange (no \"Apply\" button)\n    - Validate inputs before applying (BPM range, pattern length, etc.)\n    - Provide visual feedback (sliders show values, color pickers show current color)\n    - Make panel closable with Escape key\n    - Responsive design (sidebar on desktop, fullscreen on mobile)\n\n    Restrictions:\n    - All changes must apply in real-time\n    - Must validate inputs\n    - Keyboard accessible\n    - Clear visual hierarchy\n    - Don't overwhelm user with too many controls at once (use tabs)\n\n    Success: Settings panel is intuitive and complete, all options accessible, changes apply immediately, validation prevents invalid states, responsive design works\n    ```\n\n- [ ] 6.3. Create MetronomeOverlay component\n  - File: `frontend/src/components/MetronomeOverlay.tsx`\n  - Implement top-level container orchestrating all metronome UI and visual effects\n  - Purpose: Main metronome component integrated into VideoPlayer\n  - _Leverage: All metronome hooks and components\n  - _Requirements: All requirements\n  - _Prompt:\n    ```\n    Role: Senior React Developer with expertise in component orchestration\n\n    Task: Create MetronomeOverlay component in frontend/src/components/MetronomeOverlay.tsx. This is the top-level orchestrator that brings everything together.\n\n    Component implementation:\n\n    ```typescript\n    import React, { useState } from 'react';\n    import { useMetronome } from '../hooks/useMetronome';\n    import { useMetronomeAudio } from '../hooks/useMetronomeAudio';\n    import { useMetronomeVisuals } from '../hooks/useMetronomeVisuals';\n    import { useMetronomePresets } from '../hooks/useMetronomePresets';\n    import { MetronomeControls } from './MetronomeControls';\n    import { MetronomeSettingsPanel } from './MetronomeSettingsPanel';\n    import { VisualEffectRenderer } from './MetronomeVisualEffects';\n    import type { UseVideoPlayerReturn } from '../hooks/useVideoPlayer';\n    import type { MetronomeConfig } from '../types/metronome';\n    import './MetronomeOverlay.css';\n\n    interface MetronomeOverlayProps {\n      playerState: UseVideoPlayerReturn;\n      initialConfig?: Partial<MetronomeConfig>;\n    }\n\n    export function MetronomeOverlay({ playerState, initialConfig }: MetronomeOverlayProps) {\n      const [settingsPanelOpen, setSettingsPanelOpen] = useState(false);\n\n      // Initialize all hooks\n      const metronome = useMetronome(playerState);\n      const audio = useMetronomeAudio(metronome.engineRef, metronome.config.audio);\n      const visuals = useMetronomeVisuals(metronome.engineRef, metronome.config.visual);\n      const presets = useMetronomePresets();\n\n      // Apply initial config if provided\n      React.useEffect(() => {\n        if (initialConfig) {\n          metronome.updateConfig(initialConfig);\n        }\n      }, []);\n\n      // Handle preset loading\n      const handleLoadPreset = (id: string) => {\n        const presetConfig = presets.loadPreset(id);\n        if (presetConfig) {\n          metronome.updateConfig(presetConfig);\n        }\n      };\n\n      // Handle preset saving\n      const handleSavePreset = (name: string) => {\n        presets.savePreset(name, metronome.config);\n      };\n\n      // Handle keyboard shortcuts\n      React.useEffect(() => {\n        const handleKeyDown = (e: KeyboardEvent) => {\n          // Only handle if not in input field\n          if (document.activeElement?.tagName === 'INPUT') return;\n\n          if (e.key === 'm' && e.ctrlKey) {\n            e.preventDefault();\n            metronome.toggle();\n          } else if (e.key === 'Escape' && settingsPanelOpen) {\n            setSettingsPanelOpen(false);\n          }\n        };\n\n        window.addEventListener('keydown', handleKeyDown);\n        return () => window.removeEventListener('keydown', handleKeyDown);\n      }, [metronome.toggle, settingsPanelOpen]);\n\n      return (\n        <div className=\"metronome-overlay\">\n          {/* Controls always visible */}\n          <div className=\"metronome-overlay__controls\">\n            <MetronomeControls\n              enabled={metronome.enabled}\n              bpm={metronome.config.bpm}\n              isRunning={metronome.isRunning}\n              onToggle={metronome.toggle}\n              onBPMChange={(bpm) => metronome.updateConfig({ bpm })}\n              onOpenSettings={() => setSettingsPanelOpen(true)}\n            />\n          </div>\n\n          {/* Settings panel (conditional) */}\n          {settingsPanelOpen && (\n            <MetronomeSettingsPanel\n              config={metronome.config}\n              presets={presets.presets}\n              onConfigChange={metronome.updateConfig}\n              onLoadPreset={handleLoadPreset}\n              onSavePreset={handleSavePreset}\n              onDeletePreset={presets.deletePreset}\n              onClose={() => setSettingsPanelOpen(false)}\n            />\n          )}\n\n          {/* Visual effects */}\n          {metronome.enabled && (\n            <VisualEffectRenderer\n              effect={visuals.activeEffect}\n              config={metronome.config.visual}\n            />\n          )}\n\n          {/* Error messages */}\n          {audio.audioError && (\n            <div className=\"metronome-overlay__error\">\n              {audio.audioError}\n            </div>\n          )}\n          {presets.error && (\n            <div className=\"metronome-overlay__error\">\n              {presets.error}\n            </div>\n          )}\n        </div>\n      );\n    }\n    ```\n\n    CSS (MetronomeOverlay.css):\n    ```css\n    .metronome-overlay {\n      position: relative;\n      width: 100%;\n      height: 100%;\n    }\n\n    .metronome-overlay__controls {\n      position: absolute;\n      bottom: 60px; /* Above video controls */\n      right: 20px;\n      z-index: 10;\n    }\n\n    .metronome-overlay__error {\n      position: fixed;\n      bottom: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      padding: 12px 24px;\n      background: rgba(255, 0, 0, 0.9);\n      color: white;\n      border-radius: 8px;\n      z-index: 10000;\n      max-width: 400px;\n      text-align: center;\n    }\n    ```\n\n    Restrictions:\n    - Must not block video player controls\n    - Handle all error states gracefully\n    - Keyboard shortcuts must not conflict with video player\n    - Proper z-index layering\n\n    Success: All components work together seamlessly, keyboard shortcuts work, error handling is clear, visual effects render correctly\n    ```\n\n## Phase 7: VideoPlayer Integration\n\n- [ ] 7. Integrate MetronomeOverlay into VideoPlayer\n  - File: `frontend/src/components/VideoPlayer.tsx` (modify existing)\n  - Add MetronomeOverlay as sibling to video element, pass playerInstance\n  - Purpose: Make metronome available in video player\n  - _Leverage: Existing VideoPlayer component, useVideoPlayer hook\n  - _Requirements: All requirements\n  - _Prompt:\n    ```\n    Role: React Developer with expertise in component integration\n\n    Task: Integrate MetronomeOverlay into existing VideoPlayer component in frontend/src/components/VideoPlayer.tsx.\n\n    Modifications needed:\n\n    1. Import MetronomeOverlay:\n    ```typescript\n    import { MetronomeOverlay } from './MetronomeOverlay';\n    ```\n\n    2. Add prop to enable metronome (optional):\n    ```typescript\n    interface VideoPlayerProps {\n      // ... existing props ...\n      metronomeEnabled?: boolean; // Optional: enable metronome for this player\n    }\n    ```\n\n    3. Render MetronomeOverlay as sibling to video element:\n    ```typescript\n    export default function VideoPlayer({\n      videoId,\n      clipId,\n      autoplay = false,\n      controls = true,\n      className = '',\n      playerInstance,\n      metronomeEnabled = true, // Enable by default\n    }: VideoPlayerProps) {\n      const videoElementRef = useRef<HTMLVideoElement>(null);\n      const internalPlayer = useVideoPlayer();\n      const player = playerInstance || internalPlayer;\n\n      // ... existing player initialization ...\n\n      return (\n        <div className={`video-player ${className}`} data-vjs-player>\n          {/* Existing video element */}\n          <video\n            ref={videoElementRef}\n            className=\"video-js vjs-big-play-centered vjs-theme-fantasy\"\n            playsInline\n            data-testid=\"video-player\"\n          />\n\n          {/* Existing loading/error overlays ... */}\n\n          {/* NEW: Metronome overlay */}\n          {metronomeEnabled && (\n            <MetronomeOverlay playerState={player} />\n          )}\n        </div>\n      );\n    }\n    ```\n\n    4. Update CSS to handle metronome overlay positioning:\n    - Ensure metronome controls don't overlap with video controls\n    - Z-index: video controls at 100, metronome at 10, visual effects at 9999\n\n    Restrictions:\n    - Must not break existing VideoPlayer functionality\n    - Metronome should be optional (can be disabled via prop)\n    - Proper z-index layering to avoid conflicts\n    - No visual glitches or overlaps\n\n    Leverage:\n    - Existing VideoPlayer.tsx structure\n    - useVideoPlayer hook (player instance)\n\n    Success: Metronome appears in video player, syncs with playback, doesn't break existing functionality, can be toggled on/off\n    ```\n\n## Phase 8: Testing\n\n- [ ] 8.1. Create unit tests for timing utilities\n  - File: `frontend/src/utils/metronome/__tests__/timingCalculations.test.ts`\n  - Test all timing calculation functions\n  - Purpose: Ensure timing math is accurate\n  - _Leverage: Jest\n  - _Requirements: REQ-10 (Performance)\n  - _Prompt:\n    ```\n    Role: QA Engineer specializing in unit testing and JavaScript\n\n    Task: Create comprehensive unit tests for timing utilities in frontend/src/utils/metronome/__tests__/timingCalculations.test.ts.\n\n    Test structure:\n\n    ```typescript\n    import {\n      bpmToMilliseconds,\n      millisecondsToBPM,\n      calculateBeatDuration,\n      applyTempoChange,\n      calculateBeatFromTime,\n      validateBPM,\n    } from '../timingCalculations';\n\n    describe('timingCalculations', () => {\n      describe('bpmToMilliseconds', () => {\n        it('converts 60 BPM to 1000ms', () => {\n          expect(bpmToMilliseconds(60)).toBe(1000);\n        });\n\n        it('converts 120 BPM to 500ms', () => {\n          expect(bpmToMilliseconds(120)).toBe(500);\n        });\n\n        it('handles minimum BPM (30)', () => {\n          expect(bpmToMilliseconds(30)).toBe(2000);\n        });\n\n        it('handles maximum BPM (300)', () => {\n          expect(bpmToMilliseconds(300)).toBeCloseTo(200, 0);\n        });\n\n        it('throws error for invalid BPM', () => {\n          expect(() => bpmToMilliseconds(0)).toThrow();\n          expect(() => bpmToMilliseconds(-10)).toThrow();\n        });\n      });\n\n      describe('millisecondsToBPM', () => {\n        it('converts 1000ms to 60 BPM', () => {\n          expect(millisecondsToBPM(1000)).toBe(60);\n        });\n\n        it('is inverse of bpmToMilliseconds', () => {\n          const bpm = 120;\n          const ms = bpmToMilliseconds(bpm);\n          expect(millisecondsToBPM(ms)).toBeCloseTo(bpm, 2);\n        });\n      });\n\n      describe('calculateBeatDuration', () => {\n        it('returns exact duration with 0% randomization', () => {\n          const duration = calculateBeatDuration(60, 0);\n          expect(duration).toBe(1000);\n        });\n\n        it('returns duration within range with randomization', () => {\n          const duration = calculateBeatDuration(60, 20); // ±20%\n          expect(duration).toBeGreaterThanOrEqual(800);\n          expect(duration).toBeLessThanOrEqual(1200);\n        });\n      });\n\n      describe('applyTempoChange', () => {\n        it('accelerates BPM correctly', () => {\n          const config = {\n            mode: 'accelerate' as const,\n            changePerMinute: 10,\n            minBPM: 30,\n            maxBPM: 300,\n            resetOnStop: true,\n          };\n          const newBPM = applyTempoChange(60, config, 1); // 1 minute elapsed\n          expect(newBPM).toBe(70); // 60 + 10\n        });\n\n        it('respects max BPM bound', () => {\n          const config = {\n            mode: 'accelerate' as const,\n            changePerMinute: 50,\n            minBPM: 30,\n            maxBPM: 120,\n            resetOnStop: true,\n          };\n          const newBPM = applyTempoChange(110, config, 1);\n          expect(newBPM).toBe(120); // Capped at maxBPM\n        });\n\n        // Add tests for decelerate and cycle modes\n      });\n\n      describe('calculateBeatFromTime', () => {\n        it('calculates beat number at time 0', () => {\n          expect(calculateBeatFromTime(0, 60)).toBe(0);\n        });\n\n        it('calculates beat number after 1 second at 60 BPM', () => {\n          expect(calculateBeatFromTime(1, 60)).toBe(1);\n        });\n\n        it('calculates beat number after 2.5 seconds at 120 BPM', () => {\n          expect(calculateBeatFromTime(2.5, 120)).toBe(5); // 2.5s * 2 beats/s\n        });\n      });\n\n      describe('validateBPM', () => {\n        it('returns true for valid BPM', () => {\n          expect(validateBPM(60)).toBe(true);\n          expect(validateBPM(120)).toBe(true);\n          expect(validateBPM(30)).toBe(true);\n          expect(validateBPM(300)).toBe(true);\n        });\n\n        it('returns false for invalid BPM', () => {\n          expect(validateBPM(0)).toBe(false);\n          expect(validateBPM(29)).toBe(false);\n          expect(validateBPM(301)).toBe(false);\n          expect(validateBPM(-10)).toBe(false);\n        });\n      });\n    });\n    ```\n\n    Success: All utility functions covered, edge cases tested, timing calculations verified accurate\n    ```\n\n- [ ] 8.2. Create unit tests for MetronomeEngine\n  - File: `frontend/src/services/metronome/__tests__/MetronomeEngine.test.ts`\n  - Test engine initialization, beat scheduling, pattern handling\n  - Purpose: Ensure core engine reliability\n  - _Leverage: Jest, mock Web Audio API\n  - _Requirements: REQ-1, REQ-3, REQ-10\n  - _Prompt:\n    ```\n    Role: QA Engineer specializing in integration testing and mocking\n\n    Task: Create unit tests for MetronomeEngine in frontend/src/services/metronome/__tests__/MetronomeEngine.test.ts.\n\n    Key tests to implement:\n    1. Engine initialization\n    2. Beat event emission\n    3. Pattern looping\n    4. BPM changes during playback\n    5. Pause/resume functionality\n    6. Dispose cleanup\n    7. Beat timing accuracy (use mock timers)\n\n    Mock Web Audio API:\n    ```typescript\n    const mockAudioContext = {\n      currentTime: 0,\n      state: 'running',\n    };\n\n    beforeAll(() => {\n      (global as any).AudioContext = jest.fn(() => mockAudioContext);\n    });\n    ```\n\n    Use Jest fake timers:\n    ```typescript\n    beforeEach(() => {\n      jest.useFakeTimers();\n    });\n\n    afterEach(() => {\n      jest.runOnlyPendingTimers();\n      jest.useRealTimers();\n    });\n    ```\n\n    Success: Engine behavior verified, edge cases covered, timing accuracy tested, cleanup verified\n    ```\n\n- [ ] 8.3. Create component tests for visual effects\n  - File: `frontend/src/components/visualEffects/__tests__/`\n  - Test FlashEffect, PulseEffect, BorderEffect rendering and animations\n  - Purpose: Ensure visual effects render correctly\n  - _Leverage: @testing-library/react, Jest\n  - _Requirements: REQ-2, REQ-5\n  - _Prompt:\n    ```\n    Role: Frontend QA Engineer specializing in React component testing\n\n    Task: Create component tests for visual effects in frontend/src/components/visualEffects/__tests__/.\n\n    Create separate test files:\n    - FlashEffect.test.tsx\n    - PulseEffect.test.tsx\n    - BorderEffect.test.tsx\n\n    Test structure for FlashEffect:\n    ```typescript\n    import { render } from '@testing-library/react';\n    import { FlashEffect } from '../FlashEffect';\n\n    describe('FlashEffect', () => {\n      it('renders with correct opacity', () => {\n        const { container } = render(\n          <FlashEffect\n            intensity={0.5}\n            duration={300}\n            config={{ color: '#ffffff', opacity: 0.5 }}\n          />\n        );\n\n        const effect = container.querySelector('.flash-effect');\n        expect(effect).toBeInTheDocument();\n        // Check computed styles\n      });\n\n      it('applies color correctly', () => {\n        const { container } = render(\n          <FlashEffect\n            intensity={1}\n            duration={300}\n            config={{ color: '#ff0000', opacity: 1 }}\n          />\n        );\n\n        const effect = container.querySelector('.flash-effect');\n        const styles = window.getComputedStyle(effect!);\n        expect(styles.getPropertyValue('--flash-color')).toBe('#ff0000');\n      });\n\n      it('calls onComplete after duration', async () => {\n        jest.useFakeTimers();\n        const onComplete = jest.fn();\n\n        render(\n          <FlashEffect\n            intensity={1}\n            duration={300}\n            config={{ color: '#ffffff', opacity: 1 }}\n            onComplete={onComplete}\n          />\n        );\n\n        jest.advanceTimersByTime(300);\n        expect(onComplete).toHaveBeenCalled();\n\n        jest.useRealTimers();\n      });\n    });\n    ```\n\n    Similar tests for PulseEffect and BorderEffect with their specific props.\n\n    Success: All visual effects tested, props handled correctly, animations trigger, onComplete callbacks work\n    ```\n\n- [ ] 8.4. Create integration tests for metronome hooks\n  - File: `frontend/src/hooks/__tests__/useMetronome.test.ts`\n  - Test hook interactions and state management\n  - Purpose: Ensure hooks work together correctly\n  - _Leverage: @testing-library/react-hooks, Jest\n  - _Requirements: All requirements\n  - _Prompt:\n    ```\n    Role: React Testing Specialist\n\n    Task: Create integration tests for useMetronome hook in frontend/src/hooks/__tests__/useMetronome.test.ts.\n\n    Test structure:\n    ```typescript\n    import { renderHook, act } from '@testing-library/react-hooks';\n    import { useMetronome } from '../useMetronome';\n    import { useVideoPlayer } from '../useVideoPlayer';\n\n    describe('useMetronome', () => {\n      let mockPlayerState: any;\n\n      beforeEach(() => {\n        mockPlayerState = {\n          playing: false,\n          currentTime: 0,\n          duration: 100,\n          playerRef: { current: null },\n          // ... other video player state\n        };\n      });\n\n      it('initializes with default config', () => {\n        const { result } = renderHook(() => useMetronome(mockPlayerState));\n\n        expect(result.current.enabled).toBe(false);\n        expect(result.current.config.bpm).toBe(60);\n        expect(result.current.isRunning).toBe(false);\n      });\n\n      it('starts metronome when toggle is called', () => {\n        const { result } = renderHook(() => useMetronome(mockPlayerState));\n\n        act(() => {\n          result.current.toggle();\n        });\n\n        expect(result.current.enabled).toBe(true);\n      });\n\n      it('syncs with video player play state', () => {\n        const { result } = renderHook(() => useMetronome(mockPlayerState));\n\n        act(() => {\n          result.current.start();\n          mockPlayerState.playing = true;\n        });\n\n        // Trigger re-render with new player state\n        // Verify metronome is running\n      });\n\n      it('updates BPM in real-time', () => {\n        const { result } = renderHook(() => useMetronome(mockPlayerState));\n\n        act(() => {\n          result.current.updateConfig({ bpm: 120 });\n        });\n\n        expect(result.current.config.bpm).toBe(120);\n      });\n\n      it('cleans up engine on unmount', () => {\n        const { result, unmount } = renderHook(() => useMetronome(mockPlayerState));\n        const disposeSpy = jest.spyOn(result.current.engineRef.current!, 'dispose');\n\n        unmount();\n\n        expect(disposeSpy).toHaveBeenCalled();\n      });\n    });\n    ```\n\n    Success: Hook lifecycle tested, state updates verified, cleanup confirmed, video sync working\n    ```\n\n- [ ] 8.5. Create E2E tests for metronome workflows\n  - File: `e2e/metronome.spec.ts`\n  - Test complete user workflows with Playwright\n  - Purpose: Verify end-to-end functionality\n  - _Leverage: Playwright\n  - _Requirements: All requirements\n  - _Prompt:\n    ```\n    Role: E2E Test Engineer with Playwright expertise\n\n    Task: Create end-to-end tests for metronome workflows in e2e/metronome.spec.ts.\n\n    Test scenarios:\n\n    ```typescript\n    import { test, expect } from '@playwright/test';\n\n    test.describe('Metronome Feature', () => {\n      test.beforeEach(async ({ page }) => {\n        // Navigate to video player\n        await page.goto('/videos/1');\n        await page.waitForSelector('[data-testid=\"video-player\"]');\n      });\n\n      test('User can enable and disable metronome', async ({ page }) => {\n        // Find metronome toggle button\n        const toggleBtn = page.locator('[data-testid=\"metronome-toggle\"]');\n\n        // Click to enable\n        await toggleBtn.click();\n\n        // Verify metronome is active (button has active class)\n        await expect(toggleBtn).toHaveClass(/active/);\n\n        // Verify BPM slider is visible\n        await expect(page.locator('.metronome-controls__bpm-slider')).toBeVisible();\n\n        // Click to disable\n        await toggleBtn.click();\n\n        // Verify metronome is inactive\n        await expect(toggleBtn).not.toHaveClass(/active/);\n      });\n\n      test('User can adjust BPM with slider', async ({ page }) => {\n        // Enable metronome\n        await page.click('[data-testid=\"metronome-toggle\"]');\n\n        // Find BPM slider\n        const bpmSlider = page.locator('[data-testid=\"bpm-slider\"]');\n\n        // Set to 120 BPM\n        await bpmSlider.fill('120');\n\n        // Verify BPM value display shows 120\n        await expect(page.locator('.metronome-controls__bpm-value')).toHaveText('120');\n      });\n\n      test('User can open settings panel', async ({ page }) => {\n        // Enable metronome\n        await page.click('[data-testid=\"metronome-toggle\"]');\n\n        // Click settings button\n        await page.click('[data-testid=\"metronome-settings-btn\"]');\n\n        // Verify settings panel is visible\n        await expect(page.locator('.metronome-settings-panel')).toBeVisible();\n\n        // Verify all tabs are present\n        await expect(page.locator('text=Basic')).toBeVisible();\n        await expect(page.locator('text=Pattern')).toBeVisible();\n        await expect(page.locator('text=Visual')).toBeVisible();\n        await expect(page.locator('text=Audio')).toBeVisible();\n        await expect(page.locator('text=Presets')).toBeVisible();\n      });\n\n      test('User can create and load preset', async ({ page }) => {\n        // Enable metronome and open settings\n        await page.click('[data-testid=\"metronome-toggle\"]');\n        await page.click('[data-testid=\"metronome-settings-btn\"]');\n\n        // Set custom BPM\n        await page.fill('[data-testid=\"bpm-input\"]', '150');\n\n        // Go to presets tab\n        await page.click('text=Presets');\n\n        // Save preset\n        await page.fill('[data-testid=\"preset-name-input\"]', 'Test Preset');\n        await page.click('[data-testid=\"save-preset-btn\"]');\n\n        // Verify preset appears in list\n        await expect(page.locator('text=Test Preset')).toBeVisible();\n\n        // Change BPM\n        await page.click('text=Basic');\n        await page.fill('[data-testid=\"bpm-input\"]', '60');\n\n        // Load preset\n        await page.click('text=Presets');\n        await page.click('[data-testid=\"load-preset-Test Preset\"]');\n\n        // Verify BPM restored to 150\n        await page.click('text=Basic');\n        await expect(page.locator('[data-testid=\"bpm-input\"]')).toHaveValue('150');\n      });\n\n      test('Metronome syncs with video playback', async ({ page }) => {\n        // Enable metronome\n        await page.click('[data-testid=\"metronome-toggle\"]');\n\n        // Play video\n        await page.click('[data-testid=\"video-player\"]'); // Click to play\n\n        // Wait a moment\n        await page.waitForTimeout(500);\n\n        // Verify metronome is running (pulse indicator visible)\n        await expect(page.locator('.pulse-indicator')).toBeVisible();\n\n        // Pause video\n        await page.click('[data-testid=\"video-player\"]'); // Click to pause\n\n        // Verify metronome stops (pulse indicator may still be visible but not animating)\n        // This is hard to test visually, might need to check engine state via exposed data attribute\n      });\n\n      test('Visual effects render on beats', async ({ page }) => {\n        // Enable metronome\n        await page.click('[data-testid=\"metronome-toggle\"]');\n\n        // Open settings and ensure flash effect is enabled\n        await page.click('[data-testid=\"metronome-settings-btn\"]');\n        await page.click('text=Visual');\n        await page.selectOption('[data-testid=\"visual-style-select\"]', 'flash');\n        await page.click('[data-testid=\"close-settings\"]');\n\n        // Play video\n        await page.click('[data-testid=\"video-player\"]');\n\n        // Wait for a beat\n        await page.waitForTimeout(1000); // 60 BPM = 1 beat per second\n\n        // Check if flash effect appeared (this is timing-sensitive, might be flaky)\n        // Better approach: mock time or use test mode with manual beat triggers\n        const flashEffect = page.locator('.flash-effect');\n        // Verify it exists (even if animation completed)\n      });\n    });\n    ```\n\n    Notes:\n    - Some tests may be timing-sensitive and potentially flaky\n    - Consider adding test modes or manual beat triggers for more reliable testing\n    - Visual effect tests are particularly challenging without video recording\n\n    Success: All major workflows tested, user can enable/disable metronome, settings work, presets function, video sync confirmed\n    ```\n\n## Phase 9: Documentation\n\n- [ ] 9. Create user documentation\n  - File: `docs/METRONOME.md`\n  - Write comprehensive user guide for metronome feature\n  - Purpose: Help users understand and use the metronome\n  - _Leverage: None\n  - _Requirements: All requirements\n  - _Prompt:\n    ```\n    Role: Technical Writer with expertise in user documentation\n\n    Task: Create comprehensive user documentation in docs/METRONOME.md for the metronome overlay feature.\n\n    Documentation structure:\n\n    # Metronome Overlay Feature\n\n    ## Overview\n    Brief description of what the metronome overlay does and why it's useful.\n\n    ## Getting Started\n    ### Enabling the Metronome\n    Step-by-step instructions with screenshots (if available):\n    1. Open a video in the player\n    2. Click the metronome button in the controls\n    3. Adjust BPM as desired\n\n    ## Basic Controls\n    ### BPM Control\n    - Description of BPM (beats per minute)\n    - How to adjust (slider, input field)\n    - Valid range (30-300)\n\n    ### Play/Pause\n    - Automatic sync with video playback\n    - Manual start/stop\n\n    ## Settings Panel\n\n    ### Basic Tab\n    - BPM fine-tuning\n    - Randomization settings\n    - Tempo change options\n    - Sync preferences\n\n    ### Pattern Tab\n    - Creating custom beat patterns\n    - Setting beat intensities (light, medium, strong, silent)\n    - Accent beats\n\n    ### Visual Tab\n    - Visual effect types (flash, pulse, border)\n    - Customizing colors and opacity\n    - Position and size controls\n\n    ### Audio Tab\n    - Selecting sound types\n    - Volume control\n    - Custom sound upload\n    - Volume variation\n\n    ### Presets Tab\n    - Saving presets\n    - Loading presets\n    - Deleting presets\n    - Import/Export\n\n    ## Use Cases\n    Examples of when to use the metronome:\n    - Rhythm training\n    - Exercise timing\n    - Music practice\n    - Pacing during instructional videos\n\n    ## Keyboard Shortcuts\n    - Ctrl+M: Toggle metronome\n    - Arrow keys: Adjust BPM (when focused)\n    - Escape: Close settings panel\n\n    ## Troubleshooting\n\n    ### Audio Not Playing\n    - Check volume settings\n    - Verify browser audio permissions\n    - Try different sound types\n\n    ### Visual Effects Not Showing\n    - Check visual enabled setting\n    - Verify opacity is not set to 0\n    - Try different effect styles\n\n    ### Timing Issues\n    - Close other tabs/applications\n    - Check browser performance\n    - Reduce visual complexity\n\n    ### Storage Quota Errors\n    - Delete unused presets\n    - Export presets to file\n    - Clear browser cache\n\n    ## Technical Details\n    - Timing accuracy: ±5ms\n    - Supported browsers: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+\n    - Storage: Uses browser localStorage (up to 5MB)\n\n    ## FAQ\n    Common questions and answers\n\n    Success: Documentation is clear, comprehensive, well-organized, includes troubleshooting, easy for users to follow\n    ```\n\n---\n\n## Task Completion Guidelines\n\n### For Each Task:\n\n1. **Before Starting**:\n   - Read requirements.md and design.md in `.spec-workflow/specs/metronome-overlay/`\n   - Understand the task's purpose and dependencies\n   - Check `_Leverage` field for code to reuse\n\n2. **During Implementation**:\n   - Follow the _Prompt instructions exactly\n   - Write clean, well-documented code\n   - Add TypeScript types for everything\n   - Include JSDoc comments\n   - Handle errors gracefully\n\n3. **After Completion**:\n   - Test the implementation manually\n   - Run relevant unit tests\n   - Mark task as complete: Change `- [ ]` to `- [x]` in this file\n   - Log implementation details (see instructions in spec-workflow-guide)\n\n4. **Task Status Markers**:\n   - `- [ ]` = Pending (not started)\n   - `- [-]` = In Progress (currently working on)\n   - `- [x]` = Completed (finished and tested)\n\n### Dependencies:\n\n- Phase 1 must complete before Phase 2\n- Phase 2 must complete before Phases 3 and 4 (can run in parallel)\n- Phase 5 depends on Phases 2, 3, and 4\n- Phase 6 depends on Phase 5\n- Phase 7 depends on Phase 6\n- Phase 8 can start after Phase 6 (test while developing Phase 7)\n- Phase 9 can be done anytime after Phase 6\n\n### Notes for Claude Web (Without Agents):\n\nSince Claude Web doesn't have access to MCP servers and agents, follow these additional guidelines:\n\n1. **Read files explicitly**: Use commands like \"read the file at [path]\" to examine code\n2. **Search manually**: Use \"search for [pattern] in [directory]\" to find references\n3. **Test incrementally**: Test each component immediately after implementation\n4. **Ask for clarification**: If prompts are unclear, ask the user for guidance\n5. **Break down further**: If a task is too large, break it into sub-tasks\n6. **Validate assumptions**: Before implementing, confirm understanding with user\n7. **Handle missing context**: If you need information from other files, explicitly request it\n\n### Implementation Log Instructions:\n\nAfter completing each task, you should log the implementation using the log-implementation tool (if available) or create a manual log entry with:\n- Task ID (e.g., \"1\", \"2.1\", \"5.2\")\n- Summary of what was implemented\n- Files created/modified\n- Code statistics (lines added/removed)\n- **Artifacts** (REQUIRED): Document any APIs, components, functions, classes created with full details\n\nExample log entry format:\n```\nTask 2.2: Created MetronomeEngine core class\n\nFiles Created:\n- frontend/src/services/metronome/MetronomeEngine.ts\n\nFiles Modified:\n- None\n\nStatistics:\n- Lines Added: 350\n- Lines Removed: 0\n\nArtifacts:\n- Class: MetronomeEngine\n  - Purpose: Core timing engine using Web Audio API\n  - Methods: start, stop, pause, resume, updateBPM, updatePattern, seekToBeat, on, off, getCurrentBeat, dispose\n  - Location: frontend/src/services/metronome/MetronomeEngine.ts\n\nDescription:\nImplemented the core MetronomeEngine class using Web Audio API with look-ahead scheduling. The engine maintains sub-5ms timing accuracy and emits beat events that other components can subscribe to. Includes pattern support, BPM changes, and proper cleanup.\n```\n",
  "fileStats": {
    "size": 89109,
    "lines": 2685,
    "lastModified": "2025-11-10T09:50:35.069Z"
  },
  "comments": []
}