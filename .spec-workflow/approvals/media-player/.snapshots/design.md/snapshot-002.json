{
  "id": "snapshot_1762612234734_6nzx30mhb",
  "approvalId": "approval_1762612082749_06e6b8wop",
  "approvalTitle": "Design Document - Media Player",
  "version": 2,
  "timestamp": "2025-11-08T14:30:34.734Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis document outlines the technical design for a self-hosted web media player application built with TypeScript, Node.js, and React. The system follows a modern three-tier architecture with a REST API backend, React SPA frontend, and database abstraction layer supporting both MySQL and PostgreSQL. The application will be containerized using Docker and support HLS adaptive bitrate streaming for optimal video playback.\n\nThe design emphasizes modularity, testability, and maintainability through clear separation of concerns, the adapter pattern for database abstraction, and component-based frontend architecture.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nSince this is a new project, we'll establish the following technical standards:\n\n- **Language**: TypeScript 5.x for type safety across frontend and backend\n- **Backend Framework**: Express.js for REST API\n- **Frontend Framework**: React 18+ with functional components and hooks\n- **Database**: Support for MySQL 8+ and PostgreSQL 14+ via adapter pattern\n- **Containerization**: Docker with multi-stage builds\n- **Code Quality**: ESLint, Prettier, and strict TypeScript compiler options\n\n### Project Structure (structure.md)\n\n```\nmedia-player/\n├── backend/\n│   ├── src/\n│   │   ├── adapters/          # Database adapter implementations\n│   │   ├── models/             # Data models and TypeScript interfaces\n│   │   ├── services/           # Business logic layer\n│   │   ├── controllers/        # API route handlers\n│   │   ├── middleware/         # Express middleware (auth, validation, error handling)\n│   │   ├── migrations/         # Database migration files\n│   │   ├── utils/              # Utility functions\n│   │   └── server.ts           # Application entry point\n│   ├── Dockerfile\n│   └── package.json\n├── frontend/\n│   ├── src/\n│   │   ├── components/         # Reusable React components\n│   │   ├── pages/              # Page-level components\n│   │   ├── services/           # API client services\n│   │   ├── hooks/              # Custom React hooks\n│   │   ├── contexts/           # React context providers\n│   │   ├── types/              # TypeScript type definitions\n│   │   └── App.tsx             # Main application component\n│   ├── Dockerfile\n│   └── package.json\n├── docker-compose.yml\n└── README.md\n```\n\n## Code Reuse Analysis\n\nSince this is a greenfield project, we'll establish reusable patterns and utilities from the start:\n\n### Foundation Components to Create\n\n- **DatabaseAdapter Interface**: Abstract interface for database operations\n- **BaseController**: Common controller patterns (error handling, response formatting)\n- **VideoScanner Service**: Reusable file system scanning logic\n- **AuthMiddleware**: Authentication token validation\n- **VideoPlayer Component**: Core player with extensible controls\n- **APIClient Service**: Centralized HTTP client with error handling\n\n### Integration Points\n\n- **FFmpeg**: For video metadata extraction and HLS transcoding\n- **bcrypt/argon2**: For password hashing\n- **jsonwebtoken**: For session token generation\n- **Video.js or ReactPlayer**: Base video player library to extend with custom controls\n\n## Architecture\n\nThe application follows a three-tier architecture with clear separation between presentation, business logic, and data access layers.\n\n### Modular Design Principles\n\n- **Single File Responsibility**: Each service handles one domain (VideoService, ClipService, PlaylistService, AuthService)\n- **Component Isolation**: React components are small and focused (VideoPlayer, ClipMarker, PlaylistEditor)\n- **Service Layer Separation**: Controllers delegate business logic to services, services use database adapters\n- **Utility Modularity**: Separate utilities for file operations, validation, error handling, and logging\n\n```mermaid\ngraph TD\n    A[React Frontend] -->|HTTP/REST| B[Express API Server]\n    B --> C[Authentication Middleware]\n    C --> D[Controllers]\n    D --> E[Services Layer]\n    E --> F[Database Adapter Interface]\n    F --> G[MySQL Adapter]\n    F --> H[PostgreSQL Adapter]\n    E --> I[File System Service]\n    I --> J[Video Files on Mounted Volume]\n    E --> K[Video Processing Service]\n    K --> L[FFmpeg]\n\n    style A fill:#61dafb\n    style B fill:#68a063\n    style F fill:#ffd700\n    style G fill:#4479a1\n    style H fill:#336791\n```\n\n### Technology Stack\n\n**Backend:**\n- **Runtime**: Node.js 20 LTS\n- **Language**: TypeScript 5.x\n- **Framework**: Express.js 4.x\n- **Database**: MySQL 8+ OR PostgreSQL 14+\n- **ORM/Query Builder**: None (raw SQL with parameterized queries for adapter pattern)\n- **Authentication**: jsonwebtoken for JWT tokens\n- **Password Hashing**: bcrypt (preferred for simplicity)\n- **Video Processing**: FFmpeg (for metadata extraction, HLS generation)\n- **Validation**: Joi or Zod for request validation\n\n**Frontend:**\n- **Framework**: React 18+\n- **Language**: TypeScript 5.x\n- **State Management**: React Context API + useReducer (start simple, can migrate to Redux if needed)\n- **Video Player**: Video.js with custom controls OR ReactPlayer\n- **HTTP Client**: Axios\n- **Routing**: React Router 6\n- **Styling**: CSS Modules or Styled Components\n- **UI Components**: Build custom or use headless UI library (Radix UI, Headless UI)\n\n**DevOps:**\n- **Containerization**: Docker with multi-stage builds\n- **Orchestration**: Docker Compose for local development\n- **Environment Config**: dotenv for environment variables\n\n## Components and Interfaces\n\n### Backend Components\n\n#### DatabaseAdapter (Interface)\n\n**Purpose:** Abstract interface defining all database operations, allowing interchangeable MySQL and PostgreSQL implementations.\n\n**Interfaces:**\n```typescript\ninterface DatabaseAdapter {\n  // Connection management\n  connect(config: DatabaseConfig): Promise<void>;\n  disconnect(): Promise<void>;\n\n  // Migration management\n  runMigrations(): Promise<void>;\n  getMigrationHistory(): Promise<Migration[]>;\n\n  // Query execution\n  query<T>(sql: string, params: any[]): Promise<T[]>;\n  execute(sql: string, params: any[]): Promise<{ affectedRows: number; insertId?: number }>;\n\n  // Transaction support\n  beginTransaction(): Promise<void>;\n  commit(): Promise<void>;\n  rollback(): Promise<void>;\n}\n```\n\n**Dependencies:** Database driver (mysql2 or pg)\n\n**Reuses:** N/A (foundation component)\n\n#### MySQLAdapter & PostgreSQLAdapter (Implementations)\n\n**Purpose:** Concrete implementations of DatabaseAdapter for MySQL and PostgreSQL.\n\n**Interfaces:** Implements DatabaseAdapter interface\n\n**Dependencies:** mysql2 OR pg driver\n\n**Reuses:** DatabaseAdapter interface\n\n#### VideoService\n\n**Purpose:** Business logic for video management (scanning, metadata, CRUD operations).\n\n**Interfaces:**\n```typescript\nclass VideoService {\n  scanVideos(mountPath: string): Promise<Video[]>;\n  getVideoById(id: number): Promise<Video | null>;\n  updateVideoMetadata(id: number, metadata: VideoMetadata): Promise<void>;\n  searchVideos(criteria: SearchCriteria): Promise<Video[]>;\n  deleteVideo(id: number): Promise<void>;\n}\n```\n\n**Dependencies:** DatabaseAdapter, FileSystemService, FFmpegService\n\n**Reuses:** DatabaseAdapter for persistence\n\n#### ClipService\n\n**Purpose:** Business logic for creating, managing, and playing clips.\n\n**Interfaces:**\n```typescript\nclass ClipService {\n  createClip(videoId: number, startTime: number, endTime: number, metadata: ClipMetadata): Promise<Clip>;\n  getClipById(id: number): Promise<Clip | null>;\n  getClipsByVideo(videoId: number): Promise<Clip[]>;\n  updateClipMetadata(id: number, metadata: ClipMetadata): Promise<void>;\n  deleteClip(id: number): Promise<void>;\n}\n```\n\n**Dependencies:** DatabaseAdapter, VideoService\n\n**Reuses:** DatabaseAdapter for persistence, VideoService for source video validation\n\n#### PlaylistService\n\n**Purpose:** Business logic for playlist creation and management.\n\n**Interfaces:**\n```typescript\nclass PlaylistService {\n  createPlaylist(name: string, description: string): Promise<Playlist>;\n  addClipToPlaylist(playlistId: number, clipId: number, order: number): Promise<void>;\n  removeClipFromPlaylist(playlistId: number, clipId: number): Promise<void>;\n  reorderPlaylist(playlistId: number, clipOrders: Array<{clipId: number, order: number}>): Promise<void>;\n  getPlaylistById(id: number): Promise<Playlist | null>;\n  deletePlaylist(id: number): Promise<void>;\n}\n```\n\n**Dependencies:** DatabaseAdapter, ClipService\n\n**Reuses:** DatabaseAdapter for persistence, ClipService for clip validation\n\n#### AuthService\n\n**Purpose:** User authentication, session management, and password handling.\n\n**Interfaces:**\n```typescript\nclass AuthService {\n  login(username: string, password: string): Promise<{ token: string; user: User }>;\n  validateToken(token: string): Promise<User | null>;\n  createUser(username: string, password: string): Promise<User>;\n  changePassword(userId: number, oldPassword: string, newPassword: string): Promise<void>;\n}\n```\n\n**Dependencies:** DatabaseAdapter, bcrypt, jsonwebtoken\n\n**Reuses:** DatabaseAdapter for user persistence\n\n#### VideoStreamingService\n\n**Purpose:** Handle video streaming with HLS support and clip-specific time ranges.\n\n**Interfaces:**\n```typescript\nclass VideoStreamingService {\n  streamVideo(videoId: number, range?: string): Promise<ReadableStream>;\n  streamClip(clipId: number): Promise<ReadableStream>;\n  generateHLSManifest(videoId: number): Promise<string>;\n  getHLSSegment(videoId: number, segmentIndex: number): Promise<Buffer>;\n}\n```\n\n**Dependencies:** FileSystemService, FFmpegService\n\n**Reuses:** FileSystemService for file access\n\n#### MigrationRunner\n\n**Purpose:** Manage database schema migrations with version tracking.\n\n**Interfaces:**\n```typescript\nclass MigrationRunner {\n  runPendingMigrations(adapter: DatabaseAdapter): Promise<void>;\n  getMigrationStatus(adapter: DatabaseAdapter): Promise<MigrationStatus[]>;\n}\n```\n\n**Dependencies:** DatabaseAdapter\n\n**Reuses:** DatabaseAdapter interface\n\n### Frontend Components\n\n#### VideoPlayer\n\n**Purpose:** Core video player component with playback controls and clip marking UI.\n\n**Props:**\n```typescript\ninterface VideoPlayerProps {\n  videoId: number;\n  clipId?: number;\n  onClipCreate?: (startTime: number, endTime: number) => void;\n  showClipMarkers?: boolean;\n}\n```\n\n**Dependencies:** Video.js or ReactPlayer library\n\n**Reuses:** VideoService API client\n\n#### ClipMarkerTimeline\n\n**Purpose:** Visual timeline showing clip markers on the video progress bar.\n\n**Props:**\n```typescript\ninterface ClipMarkerTimelineProps {\n  clips: Clip[];\n  currentTime: number;\n  duration: number;\n  onMarkerClick: (clip: Clip) => void;\n}\n```\n\n**Dependencies:** None (pure presentation)\n\n**Reuses:** N/A\n\n#### SearchFilterPanel\n\n**Purpose:** Advanced search and filter interface with multiple criteria support.\n\n**Props:**\n```typescript\ninterface SearchFilterPanelProps {\n  onSearch: (criteria: SearchCriteria) => void;\n  availableMetadataFields: MetadataField[];\n}\n```\n\n**Dependencies:** Form management library (React Hook Form)\n\n**Reuses:** VideoService API client\n\n#### PlaylistEditor\n\n**Purpose:** Drag-and-drop interface for creating and reordering playlists.\n\n**Props:**\n```typescript\ninterface PlaylistEditorProps {\n  playlistId: number;\n  onSave: (playlist: Playlist) => void;\n}\n```\n\n**Dependencies:** Drag-and-drop library (react-beautiful-dnd or @dnd-kit)\n\n**Reuses:** PlaylistService API client, ClipService API client\n\n#### LoginForm\n\n**Purpose:** User authentication form.\n\n**Props:**\n```typescript\ninterface LoginFormProps {\n  onLoginSuccess: (user: User, token: string) => void;\n}\n```\n\n**Dependencies:** Form management library\n\n**Reuses:** AuthService API client\n\n## Data Models\n\n### Video\n```typescript\ninterface Video {\n  id: number;\n  filePath: string;              // Relative path from mount point\n  title: string;\n  description: string | null;\n  tags: string[];                // Stored as JSON array\n  duration: number;              // Seconds\n  resolution: string;            // e.g., \"1920x1080\"\n  codec: string;                 // e.g., \"h264\"\n  fileSize: number;              // Bytes\n  createdAt: Date;\n  updatedAt: Date;\n  isAvailable: boolean;          // False if file no longer exists\n  customMetadata: Record<string, any>; // JSON field for extensibility\n}\n```\n\n**Database Tables:**\n```sql\n-- MySQL/PostgreSQL compatible schema\nCREATE TABLE videos (\n  id INT AUTO_INCREMENT PRIMARY KEY,           -- PostgreSQL: SERIAL PRIMARY KEY\n  file_path VARCHAR(512) NOT NULL UNIQUE,\n  title VARCHAR(255) NOT NULL,\n  description TEXT,\n  tags JSON,                                   -- PostgreSQL: JSONB\n  duration DECIMAL(10, 2) NOT NULL,\n  resolution VARCHAR(50),\n  codec VARCHAR(50),\n  file_size BIGINT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  is_available BOOLEAN DEFAULT TRUE,\n  custom_metadata JSON,                        -- PostgreSQL: JSONB\n  INDEX idx_title (title),\n  INDEX idx_created_at (created_at)\n);\n```\n\n### Clip\n```typescript\ninterface Clip {\n  id: number;\n  videoId: number;\n  name: string;\n  description: string | null;\n  startTime: number;             // Seconds from video start\n  endTime: number;               // Seconds from video start\n  duration: number;              // Calculated: endTime - startTime\n  inheritedMetadata: Record<string, any>;  // Metadata copied from source video\n  customMetadata: Record<string, any>;     // Clip-specific metadata\n  createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n**Database Tables:**\n```sql\nCREATE TABLE clips (\n  id INT AUTO_INCREMENT PRIMARY KEY,           -- PostgreSQL: SERIAL PRIMARY KEY\n  video_id INT NOT NULL,\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  start_time DECIMAL(10, 2) NOT NULL,\n  end_time DECIMAL(10, 2) NOT NULL,\n  duration DECIMAL(10, 2) GENERATED ALWAYS AS (end_time - start_time) STORED,\n  inherited_metadata JSON,                     -- PostgreSQL: JSONB\n  custom_metadata JSON,                        -- PostgreSQL: JSONB\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE,\n  INDEX idx_video_id (video_id),\n  CONSTRAINT chk_time_range CHECK (start_time < end_time)\n);\n```\n\n### Playlist\n```typescript\ninterface Playlist {\n  id: number;\n  name: string;\n  description: string | null;\n  createdAt: Date;\n  updatedAt: Date;\n  clips: PlaylistClip[];         // Ordered list of clips\n}\n\ninterface PlaylistClip {\n  clipId: number;\n  order: number;\n  clip?: Clip;                   // Populated via join\n}\n```\n\n**Database Tables:**\n```sql\nCREATE TABLE playlists (\n  id INT AUTO_INCREMENT PRIMARY KEY,           -- PostgreSQL: SERIAL PRIMARY KEY\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  INDEX idx_name (name)\n);\n\nCREATE TABLE playlist_clips (\n  playlist_id INT NOT NULL,\n  clip_id INT NOT NULL,\n  order_index INT NOT NULL,\n  PRIMARY KEY (playlist_id, clip_id),\n  FOREIGN KEY (playlist_id) REFERENCES playlists(id) ON DELETE CASCADE,\n  FOREIGN KEY (clip_id) REFERENCES clips(id) ON DELETE CASCADE,\n  INDEX idx_order (playlist_id, order_index)\n);\n```\n\n### User\n```typescript\ninterface User {\n  id: number;\n  username: string;\n  passwordHash: string;\n  createdAt: Date;\n  lastLogin: Date | null;\n}\n```\n\n**Database Tables:**\n```sql\nCREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,           -- PostgreSQL: SERIAL PRIMARY KEY\n  username VARCHAR(100) NOT NULL UNIQUE,\n  password_hash VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  last_login TIMESTAMP NULL,\n  INDEX idx_username (username)\n);\n```\n\n### Migration\n```typescript\ninterface Migration {\n  id: number;\n  version: string;\n  name: string;\n  executedAt: Date;\n}\n```\n\n**Database Tables:**\n```sql\nCREATE TABLE migrations (\n  id INT AUTO_INCREMENT PRIMARY KEY,           -- PostgreSQL: SERIAL PRIMARY KEY\n  version VARCHAR(50) NOT NULL UNIQUE,\n  name VARCHAR(255) NOT NULL,\n  executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n## API Design\n\n### REST Endpoints\n\n**Authentication:**\n- `POST /api/auth/login` - Authenticate user, returns JWT token\n- `POST /api/auth/logout` - Invalidate session (client-side token removal)\n- `GET /api/auth/validate` - Validate token, returns user info\n\n**Videos:**\n- `GET /api/videos` - List videos with pagination and filtering\n- `GET /api/videos/:id` - Get video details\n- `PATCH /api/videos/:id/metadata` - Update video metadata\n- `DELETE /api/videos/:id` - Delete video (soft delete, keeps metadata)\n- `POST /api/videos/scan` - Trigger video library scan\n- `GET /api/videos/search` - Advanced search with query parameters\n\n**Clips:**\n- `GET /api/clips` - List all clips (with optional video filter)\n- `GET /api/clips/:id` - Get clip details\n- `POST /api/clips` - Create new clip\n- `PATCH /api/clips/:id/metadata` - Update clip metadata\n- `DELETE /api/clips/:id` - Delete clip\n\n**Playlists:**\n- `GET /api/playlists` - List all playlists\n- `GET /api/playlists/:id` - Get playlist with ordered clips\n- `POST /api/playlists` - Create new playlist\n- `PUT /api/playlists/:id` - Update playlist name/description\n- `DELETE /api/playlists/:id` - Delete playlist\n- `POST /api/playlists/:id/clips` - Add clip to playlist\n- `DELETE /api/playlists/:id/clips/:clipId` - Remove clip from playlist\n- `PATCH /api/playlists/:id/reorder` - Reorder playlist clips\n\n**Streaming:**\n- `GET /api/stream/video/:id` - Stream video file (supports Range headers)\n- `GET /api/stream/clip/:id` - Stream clip (specific time range)\n- `GET /api/stream/playlist/:id` - Stream playlist (concatenated clips)\n- `GET /api/stream/hls/:id/manifest.m3u8` - HLS manifest for video\n- `GET /api/stream/hls/:id/:segment.ts` - HLS segment\n\n## Database Adapter Pattern Implementation\n\nThe adapter pattern ensures the application can work with either MySQL or PostgreSQL without code changes in the business logic layer.\n\n### Adapter Factory\n\n```typescript\n// adapters/index.ts\nexport function createDatabaseAdapter(type: 'mysql' | 'postgresql', config: DatabaseConfig): DatabaseAdapter {\n  switch (type) {\n    case 'mysql':\n      return new MySQLAdapter(config);\n    case 'postgresql':\n      return new PostgreSQLAdapter(config);\n    default:\n      throw new Error(`Unsupported database type: ${type}`);\n  }\n}\n```\n\n### SQL Dialect Translation\n\nEach adapter translates common operations to database-specific syntax:\n\n**MySQL:**\n- Auto-increment: `AUTO_INCREMENT`\n- JSON type: `JSON`\n- Last insert ID: `connection.insertId`\n- Parameter placeholder: `?`\n\n**PostgreSQL:**\n- Auto-increment: `SERIAL`\n- JSON type: `JSONB` (for better performance)\n- Last insert ID: `RETURNING id`\n- Parameter placeholder: `$1, $2, $3...`\n\n### Migration Files\n\nMigration files include both MySQL and PostgreSQL compatible SQL or use adapter methods:\n\n```typescript\n// migrations/001_initial_schema.ts\nexport async function up(adapter: DatabaseAdapter): Promise<void> {\n  const isMySQL = adapter.constructor.name === 'MySQLAdapter';\n\n  const createVideosTable = isMySQL\n    ? `CREATE TABLE videos (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        file_path VARCHAR(512) NOT NULL UNIQUE,\n        ...\n      )`\n    : `CREATE TABLE videos (\n        id SERIAL PRIMARY KEY,\n        file_path VARCHAR(512) NOT NULL UNIQUE,\n        ...\n      )`;\n\n  await adapter.execute(createVideosTable, []);\n}\n```\n\n## Video Streaming Approach\n\n### HLS Adaptive Bitrate Streaming\n\n1. **Video Ingestion:**\n   - When videos are scanned, FFmpeg extracts metadata\n   - Optionally pre-generate HLS segments for common videos\n\n2. **On-Demand Transcoding:**\n   - Generate HLS manifest and segments on-demand\n   - Cache generated segments to disk\n   - Serve segments as static files\n\n3. **Clip Streaming:**\n   - For clips, extract specific time range using FFmpeg\n   - Generate temporary HLS segments for the clip time range\n   - Stream to client\n\n4. **Playlist Streaming:**\n   - Concatenate clip segments in playlist order\n   - Generate master manifest pointing to clip segments\n\n### FFmpeg Integration\n\n```typescript\n// services/FFmpegService.ts\nclass FFmpegService {\n  extractMetadata(filePath: string): Promise<VideoMetadata>;\n  generateHLSSegments(filePath: string, outputDir: string): Promise<void>;\n  extractClipSegment(filePath: string, startTime: number, endTime: number, outputPath: string): Promise<void>;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Database Connection Failure**\n   - **Handling:** Retry connection with exponential backoff (3 attempts)\n   - **User Impact:** Display \"Service temporarily unavailable\" message\n\n2. **Video File Not Found**\n   - **Handling:** Mark video as unavailable in database, return 404\n   - **User Impact:** Display \"Video unavailable\" with option to hide unavailable videos\n\n3. **Invalid Clip Time Range**\n   - **Handling:** Validate start < end and both within video duration, return 400 with validation errors\n   - **User Impact:** Display validation error in clip creation form\n\n4. **Migration Failure**\n   - **Handling:** Rollback transaction, log error details, prevent application startup\n   - **User Impact:** Application doesn't start, admin sees error logs\n\n5. **Authentication Failure**\n   - **Handling:** Return 401 Unauthorized, don't reveal whether username or password was incorrect\n   - **User Impact:** Display \"Invalid credentials\" message\n\n6. **Insufficient Permissions (File System)**\n   - **Handling:** Log error, skip file during scanning, continue processing\n   - **User Impact:** Admin notification of skipped files\n\n7. **FFmpeg Processing Error**\n   - **Handling:** Log error, return 500 with generic message\n   - **User Impact:** Display \"Video processing failed\" message\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Framework:** Jest with ts-jest\n- **Coverage Goal:** 80%+ for services and utilities\n\n**Key Components to Test:**\n- DatabaseAdapter implementations (use in-memory SQLite for tests)\n- Service classes (VideoService, ClipService, etc.) with mocked adapters\n- Utility functions (validation, time formatting, search query building)\n- Middleware (authentication, error handling)\n\n### Integration Testing\n\n- **Framework:** Jest + Supertest for API testing\n- **Database:** Use Docker containers for MySQL and PostgreSQL test instances\n\n**Key Flows to Test:**\n- Full authentication flow (login, token validation, protected routes)\n- Video scanning and metadata extraction\n- Clip creation with metadata inheritance\n- Playlist creation and playback order\n- Search and filtering with complex criteria\n- Migration execution and rollback\n\n### End-to-End Testing\n\n- **Framework:** Playwright or Cypress\n- **Environment:** Docker Compose with test database\n\n**User Scenarios to Test:**\n1. User logs in, browses video library, plays a video\n2. User creates clips from a video, adds metadata\n3. User creates a playlist, reorders clips, plays playlist\n4. User searches for videos using multiple filters\n5. User edits clip metadata without affecting source video\n\n### Test Environment\n\nUse Docker Compose to spin up test environment:\n```yaml\nversion: '3.8'\nservices:\n  mysql-test:\n    image: mysql:8\n    environment:\n      MYSQL_ROOT_PASSWORD: test\n      MYSQL_DATABASE: media_player_test\n\n  postgres-test:\n    image: postgres:14\n    environment:\n      POSTGRES_PASSWORD: test\n      POSTGRES_DB: media_player_test\n```\n\n## Performance Considerations\n\n1. **Database Indexing:**\n   - Index on video.title, video.created_at, video.is_available\n   - Index on clip.video_id for fast clip lookups\n   - Index on playlist_clips (playlist_id, order_index) for ordered retrieval\n\n2. **Video Streaming:**\n   - Use HTTP Range headers for seeking support\n   - Cache HLS segments on disk\n   - Implement CDN-ready headers (Cache-Control)\n\n3. **Search Optimization:**\n   - For large libraries (>10k videos), consider full-text search indexes (MySQL: FULLTEXT, PostgreSQL: tsvector)\n   - Implement pagination with cursor-based pagination for better performance\n\n4. **File System Scanning:**\n   - Use batch processing with configurable batch size\n   - Implement incremental scanning (only check changed files)\n   - Store file modification timestamps to detect changes\n\n## Security Considerations\n\n1. **Authentication:**\n   - Use bcrypt with minimum 12 rounds for password hashing\n   - JWT tokens with short expiration (15 minutes) + refresh token pattern\n   - HTTP-only, secure cookies for token storage\n\n2. **Input Validation:**\n   - Validate all user inputs with Joi/Zod schemas\n   - Sanitize file paths to prevent directory traversal\n   - Parameterized queries to prevent SQL injection\n\n3. **File Access:**\n   - Restrict file reading to configured mount paths only\n   - Validate file extensions before processing\n   - Use read-only Docker volume mounts for video files\n\n4. **Rate Limiting:**\n   - Implement rate limiting on authentication endpoints (5 attempts per 15 minutes)\n   - Rate limit search endpoints to prevent abuse\n\n5. **CORS:**\n   - Configure CORS to only allow frontend origin\n   - In production, use same-origin or specific domain whitelist\n\n## Deployment Architecture\n\n### Docker Compose Setup\n\n```yaml\nversion: '3.8'\nservices:\n  backend:\n    build: ./backend\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DB_TYPE=mysql\n      - DB_HOST=db\n      - DB_PORT=3306\n      - DB_NAME=media_player\n      - DB_USER=root\n      - DB_PASSWORD=${DB_PASSWORD}\n      - JWT_SECRET=${JWT_SECRET}\n    volumes:\n      - /path/to/videos:/media:ro\n      - hls-cache:/app/cache\n    depends_on:\n      - db\n\n  frontend:\n    build: ./frontend\n    ports:\n      - \"80:80\"\n    depends_on:\n      - backend\n\n  db:\n    image: mysql:8\n    environment:\n      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}\n      - MYSQL_DATABASE=media_player\n    volumes:\n      - db-data:/var/lib/mysql\n\nvolumes:\n  db-data:\n  hls-cache:\n```\n\n### Environment Configuration\n\n```env\n# .env.example\nDB_TYPE=mysql  # or postgresql\nDB_HOST=localhost\nDB_PORT=3306   # or 5432 for PostgreSQL\nDB_NAME=media_player\nDB_USER=root\nDB_PASSWORD=changeme\nJWT_SECRET=your-secret-key-here\nVIDEO_MOUNT_PATH=/media\nPORT=3000\n```\n",
  "fileStats": {
    "size": 26454,
    "lines": 864,
    "lastModified": "2025-11-08T14:27:54.004Z"
  },
  "comments": []
}